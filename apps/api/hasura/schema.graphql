schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
Oauth requests, inserted before redirecting to the provider's site. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviderRequests {
  id: uuid!
  options(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.provider_requests"
"""
type authProviderRequests_aggregate {
  aggregate: authProviderRequests_aggregate_fields
  nodes: [authProviderRequests!]!
}

"""
aggregate fields of "auth.provider_requests"
"""
type authProviderRequests_aggregate_fields {
  count(columns: [authProviderRequests_select_column!], distinct: Boolean): Int!
  max: authProviderRequests_max_fields
  min: authProviderRequests_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_append_input {
  options: jsonb
}

"""
Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'.
"""
input authProviderRequests_bool_exp {
  _and: [authProviderRequests_bool_exp!]
  _not: authProviderRequests_bool_exp
  _or: [authProviderRequests_bool_exp!]
  id: uuid_comparison_exp
  options: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.provider_requests"
"""
enum authProviderRequests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  provider_requests_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authProviderRequests_delete_at_path_input {
  options: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authProviderRequests_delete_elem_input {
  options: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authProviderRequests_delete_key_input {
  options: String
}

"""
input type for inserting data into table "auth.provider_requests"
"""
input authProviderRequests_insert_input {
  id: uuid
  options: jsonb
}

"""aggregate max on columns"""
type authProviderRequests_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type authProviderRequests_min_fields {
  id: uuid
}

"""
response of any mutation on the table "auth.provider_requests"
"""
type authProviderRequests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviderRequests!]!
}

"""
on_conflict condition type for table "auth.provider_requests"
"""
input authProviderRequests_on_conflict {
  constraint: authProviderRequests_constraint!
  update_columns: [authProviderRequests_update_column!]! = []
  where: authProviderRequests_bool_exp
}

"""Ordering options when selecting data from "auth.provider_requests"."""
input authProviderRequests_order_by {
  id: order_by
  options: order_by
}

"""primary key columns input for table: auth.provider_requests"""
input authProviderRequests_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_prepend_input {
  options: jsonb
}

"""
select columns of table "auth.provider_requests"
"""
enum authProviderRequests_select_column {
  """column name"""
  id

  """column name"""
  options
}

"""
input type for updating data in table "auth.provider_requests"
"""
input authProviderRequests_set_input {
  id: uuid
  options: jsonb
}

"""
Streaming cursor of the table "authProviderRequests"
"""
input authProviderRequests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviderRequests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviderRequests_stream_cursor_value_input {
  id: uuid
  options: jsonb
}

"""
update columns of table "auth.provider_requests"
"""
enum authProviderRequests_update_column {
  """column name"""
  id

  """column name"""
  options
}

input authProviderRequests_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authProviderRequests_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authProviderRequests_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: authProviderRequests_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authProviderRequests_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authProviderRequests_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authProviderRequests_set_input
  where: authProviderRequests_bool_exp!
}

"""
List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviders {
  id: String!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.providers"
"""
type authProviders_aggregate {
  aggregate: authProviders_aggregate_fields
  nodes: [authProviders!]!
}

"""
aggregate fields of "auth.providers"
"""
type authProviders_aggregate_fields {
  count(columns: [authProviders_select_column!], distinct: Boolean): Int!
  max: authProviders_max_fields
  min: authProviders_min_fields
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input authProviders_bool_exp {
  _and: [authProviders_bool_exp!]
  _not: authProviders_bool_exp
  _or: [authProviders_bool_exp!]
  id: String_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum authProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input authProviders_insert_input {
  id: String
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type authProviders_max_fields {
  id: String
}

"""aggregate min on columns"""
type authProviders_min_fields {
  id: String
}

"""
response of any mutation on the table "auth.providers"
"""
type authProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviders!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input authProviders_obj_rel_insert_input {
  data: authProviders_insert_input!

  """upsert condition"""
  on_conflict: authProviders_on_conflict
}

"""
on_conflict condition type for table "auth.providers"
"""
input authProviders_on_conflict {
  constraint: authProviders_constraint!
  update_columns: [authProviders_update_column!]! = []
  where: authProviders_bool_exp
}

"""Ordering options when selecting data from "auth.providers"."""
input authProviders_order_by {
  id: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.providers"""
input authProviders_pk_columns_input {
  id: String!
}

"""
select columns of table "auth.providers"
"""
enum authProviders_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "auth.providers"
"""
input authProviders_set_input {
  id: String
}

"""
Streaming cursor of the table "authProviders"
"""
input authProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviders_stream_cursor_value_input {
  id: String
}

"""
update columns of table "auth.providers"
"""
enum authProviders_update_column {
  """column name"""
  id
}

input authProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authProviders_set_input
  where: authProviders_bool_exp!
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: uuid!
  refreshTokenHash: String

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate {
  aggregate: authRefreshTokens_aggregate_fields
  nodes: [authRefreshTokens!]!
}

input authRefreshTokens_aggregate_bool_exp {
  count: authRefreshTokens_aggregate_bool_exp_count
}

input authRefreshTokens_aggregate_bool_exp_count {
  arguments: [authRefreshTokens_select_column!]
  distinct: Boolean
  filter: authRefreshTokens_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate_fields {
  count(columns: [authRefreshTokens_select_column!], distinct: Boolean): Int!
  max: authRefreshTokens_max_fields
  min: authRefreshTokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input authRefreshTokens_arr_rel_insert_input {
  data: [authRefreshTokens_insert_input!]!

  """upsert condition"""
  on_conflict: authRefreshTokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  refreshToken: uuid_comparison_exp
  refreshTokenHash: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum authRefreshTokens_constraint {
  """
  unique or primary key constraint on columns "refresh_token"
  """
  refresh_tokens_pkey
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input authRefreshTokens_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: uuid
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authRefreshTokens_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authRefreshTokens_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input authRefreshTokens_on_conflict {
  constraint: authRefreshTokens_constraint!
  update_columns: [authRefreshTokens_update_column!]! = []
  where: authRefreshTokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  refreshTokenHash: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.refresh_tokens"""
input authRefreshTokens_pk_columns_input {
  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: uuid!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  refreshTokenHash

  """column name"""
  userId
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input authRefreshTokens_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: uuid
  userId: uuid
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokens_stream_cursor_value_input {
  createdAt: timestamptz
  expiresAt: timestamptz

  """
  DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
  """
  refreshToken: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  userId
}

input authRefreshTokens_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokens_set_input
  where: authRefreshTokens_bool_exp!
}

"""
Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRoles {
  role: String!

  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  userRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  usersByDefaultRole(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersByDefaultRole_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "auth.roles"
"""
type authRoles_aggregate {
  aggregate: authRoles_aggregate_fields
  nodes: [authRoles!]!
}

"""
aggregate fields of "auth.roles"
"""
type authRoles_aggregate_fields {
  count(columns: [authRoles_select_column!], distinct: Boolean): Int!
  max: authRoles_max_fields
  min: authRoles_min_fields
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input authRoles_bool_exp {
  _and: [authRoles_bool_exp!]
  _not: authRoles_bool_exp
  _or: [authRoles_bool_exp!]
  role: String_comparison_exp
  userRoles: authUserRoles_bool_exp
  userRoles_aggregate: authUserRoles_aggregate_bool_exp
  usersByDefaultRole: users_bool_exp
  usersByDefaultRole_aggregate: users_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum authRoles_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input authRoles_insert_input {
  role: String
  userRoles: authUserRoles_arr_rel_insert_input
  usersByDefaultRole: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type authRoles_max_fields {
  role: String
}

"""aggregate min on columns"""
type authRoles_min_fields {
  role: String
}

"""
response of any mutation on the table "auth.roles"
"""
type authRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRoles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input authRoles_obj_rel_insert_input {
  data: authRoles_insert_input!

  """upsert condition"""
  on_conflict: authRoles_on_conflict
}

"""
on_conflict condition type for table "auth.roles"
"""
input authRoles_on_conflict {
  constraint: authRoles_constraint!
  update_columns: [authRoles_update_column!]! = []
  where: authRoles_bool_exp
}

"""Ordering options when selecting data from "auth.roles"."""
input authRoles_order_by {
  role: order_by
  userRoles_aggregate: authUserRoles_aggregate_order_by
  usersByDefaultRole_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: auth.roles"""
input authRoles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum authRoles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input authRoles_set_input {
  role: String
}

"""
Streaming cursor of the table "authRoles"
"""
input authRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRoles_stream_cursor_value_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum authRoles_update_column {
  """column name"""
  role
}

input authRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRoles_set_input
  where: authRoles_bool_exp!
}

"""
Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserProviders {
  accessToken: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: authProviders!
  providerId: String!
  providerUserId: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_providers"
"""
type authUserProviders_aggregate {
  aggregate: authUserProviders_aggregate_fields
  nodes: [authUserProviders!]!
}

input authUserProviders_aggregate_bool_exp {
  count: authUserProviders_aggregate_bool_exp_count
}

input authUserProviders_aggregate_bool_exp_count {
  arguments: [authUserProviders_select_column!]
  distinct: Boolean
  filter: authUserProviders_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_providers"
"""
type authUserProviders_aggregate_fields {
  count(columns: [authUserProviders_select_column!], distinct: Boolean): Int!
  max: authUserProviders_max_fields
  min: authUserProviders_min_fields
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_providers"
"""
input authUserProviders_arr_rel_insert_input {
  data: [authUserProviders_insert_input!]!

  """upsert condition"""
  on_conflict: authUserProviders_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  accessToken: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: authProviders_bool_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  refreshToken: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_providers"
"""
enum authUserProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_providers_pkey

  """
  unique or primary key constraint on columns "provider_id", "provider_user_id"
  """
  user_providers_provider_id_provider_user_id_key

  """
  unique or primary key constraint on columns "provider_id", "user_id"
  """
  user_providers_user_id_provider_id_key
}

"""
input type for inserting data into table "auth.user_providers"
"""
input authUserProviders_insert_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  provider: authProviders_obj_rel_insert_input
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserProviders_max_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserProviders_min_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""
on_conflict condition type for table "auth.user_providers"
"""
input authUserProviders_on_conflict {
  constraint: authUserProviders_constraint!
  update_columns: [authUserProviders_update_column!]! = []
  where: authUserProviders_bool_exp
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  provider: authProviders_order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_providers"""
input authUserProviders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_providers"
"""
input authUserProviders_set_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "authUserProviders"
"""
input authUserProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserProviders_stream_cursor_value_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "auth.user_providers"
"""
enum authUserProviders_update_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

input authUserProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserProviders_set_input
  where: authUserProviders_bool_exp!
}

"""
Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: authRoles!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

input authUserRoles_aggregate_bool_exp {
  count: authUserRoles_aggregate_bool_exp_count
}

input authUserRoles_aggregate_bool_exp_count {
  arguments: [authUserRoles_select_column!]
  distinct: Boolean
  filter: authUserRoles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_roles"
"""
input authUserRoles_arr_rel_insert_input {
  data: [authUserRoles_insert_input!]!

  """upsert condition"""
  on_conflict: authUserRoles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: authRoles_bool_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role"
  """
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  roleByRole: authRoles_obj_rel_insert_input
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  roleByRole: authRoles_order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_roles"""
input authUserRoles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_roles"
"""
input authUserRoles_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
Streaming cursor of the table "authUserRoles"
"""
input authUserRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserRoles_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
update columns of table "auth.user_roles"
"""
enum authUserRoles_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

input authUserRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserRoles_set_input
  where: authUserRoles_bool_exp!
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
  counter: bigint!
  credentialId: String!
  credentialPublicKey: bytea
  id: uuid!
  nickname: String
  transports: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate {
  aggregate: authUserSecurityKeys_aggregate_fields
  nodes: [authUserSecurityKeys!]!
}

input authUserSecurityKeys_aggregate_bool_exp {
  count: authUserSecurityKeys_aggregate_bool_exp_count
}

input authUserSecurityKeys_aggregate_bool_exp_count {
  arguments: [authUserSecurityKeys_select_column!]
  distinct: Boolean
  filter: authUserSecurityKeys_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate_fields {
  avg: authUserSecurityKeys_avg_fields
  count(columns: [authUserSecurityKeys_select_column!], distinct: Boolean): Int!
  max: authUserSecurityKeys_max_fields
  min: authUserSecurityKeys_min_fields
  stddev: authUserSecurityKeys_stddev_fields
  stddev_pop: authUserSecurityKeys_stddev_pop_fields
  stddev_samp: authUserSecurityKeys_stddev_samp_fields
  sum: authUserSecurityKeys_sum_fields
  var_pop: authUserSecurityKeys_var_pop_fields
  var_samp: authUserSecurityKeys_var_samp_fields
  variance: authUserSecurityKeys_variance_fields
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
  avg: authUserSecurityKeys_avg_order_by
  count: order_by
  max: authUserSecurityKeys_max_order_by
  min: authUserSecurityKeys_min_order_by
  stddev: authUserSecurityKeys_stddev_order_by
  stddev_pop: authUserSecurityKeys_stddev_pop_order_by
  stddev_samp: authUserSecurityKeys_stddev_samp_order_by
  sum: authUserSecurityKeys_sum_order_by
  var_pop: authUserSecurityKeys_var_pop_order_by
  var_samp: authUserSecurityKeys_var_samp_order_by
  variance: authUserSecurityKeys_variance_order_by
}

"""
input type for inserting array relation for remote table "auth.user_security_keys"
"""
input authUserSecurityKeys_arr_rel_insert_input {
  data: [authUserSecurityKeys_insert_input!]!

  """upsert condition"""
  on_conflict: authUserSecurityKeys_on_conflict
}

"""aggregate avg on columns"""
type authUserSecurityKeys_avg_fields {
  counter: Float
}

"""
order by avg() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_avg_order_by {
  counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
  _and: [authUserSecurityKeys_bool_exp!]
  _not: authUserSecurityKeys_bool_exp
  _or: [authUserSecurityKeys_bool_exp!]
  counter: bigint_comparison_exp
  credentialId: String_comparison_exp
  credentialPublicKey: bytea_comparison_exp
  id: uuid_comparison_exp
  nickname: String_comparison_exp
  transports: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_security_keys"
"""
enum authUserSecurityKeys_constraint {
  """
  unique or primary key constraint on columns "credential_id"
  """
  user_security_key_credential_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_security_keys_pkey
}

"""
input type for incrementing numeric columns in table "auth.user_security_keys"
"""
input authUserSecurityKeys_inc_input {
  counter: bigint
}

"""
input type for inserting data into table "auth.user_security_keys"
"""
input authUserSecurityKeys_insert_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserSecurityKeys_max_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserSecurityKeys_min_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserSecurityKeys!]!
}

"""
on_conflict condition type for table "auth.user_security_keys"
"""
input authUserSecurityKeys_on_conflict {
  constraint: authUserSecurityKeys_constraint!
  update_columns: [authUserSecurityKeys_update_column!]! = []
  where: authUserSecurityKeys_bool_exp
}

"""Ordering options when selecting data from "auth.user_security_keys"."""
input authUserSecurityKeys_order_by {
  counter: order_by
  credentialId: order_by
  credentialPublicKey: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_security_keys"""
input authUserSecurityKeys_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_security_keys"
"""
input authUserSecurityKeys_set_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate stddev on columns"""
type authUserSecurityKeys_stddev_fields {
  counter: Float
}

"""
order by stddev() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_order_by {
  counter: order_by
}

"""aggregate stddev_pop on columns"""
type authUserSecurityKeys_stddev_pop_fields {
  counter: Float
}

"""
order by stddev_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_pop_order_by {
  counter: order_by
}

"""aggregate stddev_samp on columns"""
type authUserSecurityKeys_stddev_samp_fields {
  counter: Float
}

"""
order by stddev_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_samp_order_by {
  counter: order_by
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserSecurityKeys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserSecurityKeys_stream_cursor_value_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate sum on columns"""
type authUserSecurityKeys_sum_fields {
  counter: bigint
}

"""
order by sum() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_sum_order_by {
  counter: order_by
}

"""
update columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_update_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

input authUserSecurityKeys_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: authUserSecurityKeys_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: authUserSecurityKeys_set_input
  where: authUserSecurityKeys_bool_exp!
}

"""aggregate var_pop on columns"""
type authUserSecurityKeys_var_pop_fields {
  counter: Float
}

"""
order by var_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_pop_order_by {
  counter: order_by
}

"""aggregate var_samp on columns"""
type authUserSecurityKeys_var_samp_fields {
  counter: Float
}

"""
order by var_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_samp_order_by {
  counter: order_by
}

"""aggregate variance on columns"""
type authUserSecurityKeys_variance_fields {
  counter: Float
}

"""
order by variance() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_variance_order_by {
  counter: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "storage.buckets"
"""
type buckets {
  cacheControl: String
  createdAt: timestamptz!
  downloadExpiration: Int!

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  id: String!
  maxUploadFileSize: Int!
  minUploadFileSize: Int!
  presignedUrlsEnabled: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "storage.buckets"
"""
type buckets_aggregate {
  aggregate: buckets_aggregate_fields
  nodes: [buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type buckets_aggregate_fields {
  avg: buckets_avg_fields
  count(columns: [buckets_select_column!], distinct: Boolean): Int!
  max: buckets_max_fields
  min: buckets_min_fields
  stddev: buckets_stddev_fields
  stddev_pop: buckets_stddev_pop_fields
  stddev_samp: buckets_stddev_samp_fields
  sum: buckets_sum_fields
  var_pop: buckets_var_pop_fields
  var_samp: buckets_var_samp_fields
  variance: buckets_variance_fields
}

"""aggregate avg on columns"""
type buckets_avg_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input buckets_bool_exp {
  _and: [buckets_bool_exp!]
  _not: buckets_bool_exp
  _or: [buckets_bool_exp!]
  cacheControl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  downloadExpiration: Int_comparison_exp
  files: files_bool_exp
  files_aggregate: files_aggregate_bool_exp
  id: String_comparison_exp
  maxUploadFileSize: Int_comparison_exp
  minUploadFileSize: Int_comparison_exp
  presignedUrlsEnabled: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum buckets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input buckets_inc_input {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
input type for inserting data into table "storage.buckets"
"""
input buckets_insert_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  files: files_arr_rel_insert_input
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type buckets_max_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type buckets_min_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input buckets_obj_rel_insert_input {
  data: buckets_insert_input!

  """upsert condition"""
  on_conflict: buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input buckets_on_conflict {
  constraint: buckets_constraint!
  update_columns: [buckets_update_column!]! = []
  where: buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input buckets_order_by {
  cacheControl: order_by
  createdAt: order_by
  downloadExpiration: order_by
  files_aggregate: files_aggregate_order_by
  id: order_by
  maxUploadFileSize: order_by
  minUploadFileSize: order_by
  presignedUrlsEnabled: order_by
  updatedAt: order_by
}

"""primary key columns input for table: storage.buckets"""
input buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum buckets_select_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""
input type for updating data in table "storage.buckets"
"""
input buckets_set_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type buckets_stddev_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_pop on columns"""
type buckets_stddev_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_samp on columns"""
type buckets_stddev_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Streaming cursor of the table "buckets"
"""
input buckets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: buckets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input buckets_stream_cursor_value_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type buckets_sum_fields {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
update columns of table "storage.buckets"
"""
enum buckets_update_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

input buckets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: buckets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: buckets_set_input
  where: buckets_bool_exp!
}

"""aggregate var_pop on columns"""
type buckets_var_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate var_samp on columns"""
type buckets_var_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate variance on columns"""
type buckets_variance_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

"""
columns and relationships of "circle"
"""
type circle {
  archived: Boolean!

  """An array relationship"""
  children(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): [circle!]!

  """An aggregate relationship"""
  children_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): circle_aggregate!
  id: uuid!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): [circle_member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): circle_member_aggregate!

  """An object relationship"""
  org: org!
  orgId: uuid!

  """An object relationship"""
  parent: circle
  parentId: uuid

  """An object relationship"""
  role: role!
  roleId: uuid!
}

"""
aggregated selection of "circle"
"""
type circle_aggregate {
  aggregate: circle_aggregate_fields
  nodes: [circle!]!
}

input circle_aggregate_bool_exp {
  bool_and: circle_aggregate_bool_exp_bool_and
  bool_or: circle_aggregate_bool_exp_bool_or
  count: circle_aggregate_bool_exp_count
}

input circle_aggregate_bool_exp_bool_and {
  arguments: circle_select_column_circle_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: circle_bool_exp
  predicate: Boolean_comparison_exp!
}

input circle_aggregate_bool_exp_bool_or {
  arguments: circle_select_column_circle_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: circle_bool_exp
  predicate: Boolean_comparison_exp!
}

input circle_aggregate_bool_exp_count {
  arguments: [circle_select_column!]
  distinct: Boolean
  filter: circle_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "circle"
"""
type circle_aggregate_fields {
  count(columns: [circle_select_column!], distinct: Boolean): Int!
  max: circle_max_fields
  min: circle_min_fields
}

"""
order by aggregate values of table "circle"
"""
input circle_aggregate_order_by {
  count: order_by
  max: circle_max_order_by
  min: circle_min_order_by
}

"""
input type for inserting array relation for remote table "circle"
"""
input circle_arr_rel_insert_input {
  data: [circle_insert_input!]!

  """upsert condition"""
  on_conflict: circle_on_conflict
}

"""
Boolean expression to filter rows from the table "circle". All fields are combined with a logical 'AND'.
"""
input circle_bool_exp {
  _and: [circle_bool_exp!]
  _not: circle_bool_exp
  _or: [circle_bool_exp!]
  archived: Boolean_comparison_exp
  children: circle_bool_exp
  children_aggregate: circle_aggregate_bool_exp
  id: uuid_comparison_exp
  members: circle_member_bool_exp
  members_aggregate: circle_member_aggregate_bool_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  parent: circle_bool_exp
  parentId: uuid_comparison_exp
  role: role_bool_exp
  roleId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "circle"
"""
enum circle_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  circle_pkey
}

"""
input type for inserting data into table "circle"
"""
input circle_insert_input {
  archived: Boolean
  children: circle_arr_rel_insert_input
  id: uuid
  members: circle_member_arr_rel_insert_input
  org: org_obj_rel_insert_input
  orgId: uuid
  parent: circle_obj_rel_insert_input
  parentId: uuid
  role: role_obj_rel_insert_input
  roleId: uuid
}

"""aggregate max on columns"""
type circle_max_fields {
  id: uuid
  orgId: uuid
  parentId: uuid
  roleId: uuid
}

"""
order by max() on columns of table "circle"
"""
input circle_max_order_by {
  id: order_by
  orgId: order_by
  parentId: order_by
  roleId: order_by
}

"""
columns and relationships of "circle_member"
"""
type circle_member {
  archived: Boolean!
  avgMinPerWeek: Int

  """An object relationship"""
  circle: circle!
  circleId: uuid!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  member: member!
  memberId: uuid!
}

"""
aggregated selection of "circle_member"
"""
type circle_member_aggregate {
  aggregate: circle_member_aggregate_fields
  nodes: [circle_member!]!
}

input circle_member_aggregate_bool_exp {
  bool_and: circle_member_aggregate_bool_exp_bool_and
  bool_or: circle_member_aggregate_bool_exp_bool_or
  count: circle_member_aggregate_bool_exp_count
}

input circle_member_aggregate_bool_exp_bool_and {
  arguments: circle_member_select_column_circle_member_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: circle_member_bool_exp
  predicate: Boolean_comparison_exp!
}

input circle_member_aggregate_bool_exp_bool_or {
  arguments: circle_member_select_column_circle_member_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: circle_member_bool_exp
  predicate: Boolean_comparison_exp!
}

input circle_member_aggregate_bool_exp_count {
  arguments: [circle_member_select_column!]
  distinct: Boolean
  filter: circle_member_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "circle_member"
"""
type circle_member_aggregate_fields {
  avg: circle_member_avg_fields
  count(columns: [circle_member_select_column!], distinct: Boolean): Int!
  max: circle_member_max_fields
  min: circle_member_min_fields
  stddev: circle_member_stddev_fields
  stddev_pop: circle_member_stddev_pop_fields
  stddev_samp: circle_member_stddev_samp_fields
  sum: circle_member_sum_fields
  var_pop: circle_member_var_pop_fields
  var_samp: circle_member_var_samp_fields
  variance: circle_member_variance_fields
}

"""
order by aggregate values of table "circle_member"
"""
input circle_member_aggregate_order_by {
  avg: circle_member_avg_order_by
  count: order_by
  max: circle_member_max_order_by
  min: circle_member_min_order_by
  stddev: circle_member_stddev_order_by
  stddev_pop: circle_member_stddev_pop_order_by
  stddev_samp: circle_member_stddev_samp_order_by
  sum: circle_member_sum_order_by
  var_pop: circle_member_var_pop_order_by
  var_samp: circle_member_var_samp_order_by
  variance: circle_member_variance_order_by
}

"""
input type for inserting array relation for remote table "circle_member"
"""
input circle_member_arr_rel_insert_input {
  data: [circle_member_insert_input!]!

  """upsert condition"""
  on_conflict: circle_member_on_conflict
}

"""aggregate avg on columns"""
type circle_member_avg_fields {
  avgMinPerWeek: Float
}

"""
order by avg() on columns of table "circle_member"
"""
input circle_member_avg_order_by {
  avgMinPerWeek: order_by
}

"""
Boolean expression to filter rows from the table "circle_member". All fields are combined with a logical 'AND'.
"""
input circle_member_bool_exp {
  _and: [circle_member_bool_exp!]
  _not: circle_member_bool_exp
  _or: [circle_member_bool_exp!]
  archived: Boolean_comparison_exp
  avgMinPerWeek: Int_comparison_exp
  circle: circle_bool_exp
  circleId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  member: member_bool_exp
  memberId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "circle_member"
"""
enum circle_member_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  circle_member_pkey
}

"""
input type for incrementing numeric columns in table "circle_member"
"""
input circle_member_inc_input {
  avgMinPerWeek: Int
}

"""
input type for inserting data into table "circle_member"
"""
input circle_member_insert_input {
  archived: Boolean
  avgMinPerWeek: Int
  circle: circle_obj_rel_insert_input
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  member: member_obj_rel_insert_input
  memberId: uuid
}

"""aggregate max on columns"""
type circle_member_max_fields {
  avgMinPerWeek: Int
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  memberId: uuid
}

"""
order by max() on columns of table "circle_member"
"""
input circle_member_max_order_by {
  avgMinPerWeek: order_by
  circleId: order_by
  createdAt: order_by
  id: order_by
  memberId: order_by
}

"""aggregate min on columns"""
type circle_member_min_fields {
  avgMinPerWeek: Int
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  memberId: uuid
}

"""
order by min() on columns of table "circle_member"
"""
input circle_member_min_order_by {
  avgMinPerWeek: order_by
  circleId: order_by
  createdAt: order_by
  id: order_by
  memberId: order_by
}

"""
response of any mutation on the table "circle_member"
"""
type circle_member_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [circle_member!]!
}

"""
on_conflict condition type for table "circle_member"
"""
input circle_member_on_conflict {
  constraint: circle_member_constraint!
  update_columns: [circle_member_update_column!]! = []
  where: circle_member_bool_exp
}

"""Ordering options when selecting data from "circle_member"."""
input circle_member_order_by {
  archived: order_by
  avgMinPerWeek: order_by
  circle: circle_order_by
  circleId: order_by
  createdAt: order_by
  id: order_by
  member: member_order_by
  memberId: order_by
}

"""primary key columns input for table: circle_member"""
input circle_member_pk_columns_input {
  id: uuid!
}

"""
select columns of table "circle_member"
"""
enum circle_member_select_column {
  """column name"""
  archived

  """column name"""
  avgMinPerWeek

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  memberId
}

"""
select "circle_member_aggregate_bool_exp_bool_and_arguments_columns" columns of table "circle_member"
"""
enum circle_member_select_column_circle_member_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived
}

"""
select "circle_member_aggregate_bool_exp_bool_or_arguments_columns" columns of table "circle_member"
"""
enum circle_member_select_column_circle_member_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived
}

"""
input type for updating data in table "circle_member"
"""
input circle_member_set_input {
  archived: Boolean
  avgMinPerWeek: Int
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  memberId: uuid
}

"""aggregate stddev on columns"""
type circle_member_stddev_fields {
  avgMinPerWeek: Float
}

"""
order by stddev() on columns of table "circle_member"
"""
input circle_member_stddev_order_by {
  avgMinPerWeek: order_by
}

"""aggregate stddev_pop on columns"""
type circle_member_stddev_pop_fields {
  avgMinPerWeek: Float
}

"""
order by stddev_pop() on columns of table "circle_member"
"""
input circle_member_stddev_pop_order_by {
  avgMinPerWeek: order_by
}

"""aggregate stddev_samp on columns"""
type circle_member_stddev_samp_fields {
  avgMinPerWeek: Float
}

"""
order by stddev_samp() on columns of table "circle_member"
"""
input circle_member_stddev_samp_order_by {
  avgMinPerWeek: order_by
}

"""
Streaming cursor of the table "circle_member"
"""
input circle_member_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: circle_member_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input circle_member_stream_cursor_value_input {
  archived: Boolean
  avgMinPerWeek: Int
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  memberId: uuid
}

"""aggregate sum on columns"""
type circle_member_sum_fields {
  avgMinPerWeek: Int
}

"""
order by sum() on columns of table "circle_member"
"""
input circle_member_sum_order_by {
  avgMinPerWeek: order_by
}

"""
update columns of table "circle_member"
"""
enum circle_member_update_column {
  """column name"""
  archived

  """column name"""
  avgMinPerWeek

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  memberId
}

input circle_member_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: circle_member_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: circle_member_set_input
  where: circle_member_bool_exp!
}

"""aggregate var_pop on columns"""
type circle_member_var_pop_fields {
  avgMinPerWeek: Float
}

"""
order by var_pop() on columns of table "circle_member"
"""
input circle_member_var_pop_order_by {
  avgMinPerWeek: order_by
}

"""aggregate var_samp on columns"""
type circle_member_var_samp_fields {
  avgMinPerWeek: Float
}

"""
order by var_samp() on columns of table "circle_member"
"""
input circle_member_var_samp_order_by {
  avgMinPerWeek: order_by
}

"""aggregate variance on columns"""
type circle_member_variance_fields {
  avgMinPerWeek: Float
}

"""
order by variance() on columns of table "circle_member"
"""
input circle_member_variance_order_by {
  avgMinPerWeek: order_by
}

"""aggregate min on columns"""
type circle_min_fields {
  id: uuid
  orgId: uuid
  parentId: uuid
  roleId: uuid
}

"""
order by min() on columns of table "circle"
"""
input circle_min_order_by {
  id: order_by
  orgId: order_by
  parentId: order_by
  roleId: order_by
}

"""
response of any mutation on the table "circle"
"""
type circle_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [circle!]!
}

"""
input type for inserting object relation for remote table "circle"
"""
input circle_obj_rel_insert_input {
  data: circle_insert_input!

  """upsert condition"""
  on_conflict: circle_on_conflict
}

"""
on_conflict condition type for table "circle"
"""
input circle_on_conflict {
  constraint: circle_constraint!
  update_columns: [circle_update_column!]! = []
  where: circle_bool_exp
}

"""Ordering options when selecting data from "circle"."""
input circle_order_by {
  archived: order_by
  children_aggregate: circle_aggregate_order_by
  id: order_by
  members_aggregate: circle_member_aggregate_order_by
  org: org_order_by
  orgId: order_by
  parent: circle_order_by
  parentId: order_by
  role: role_order_by
  roleId: order_by
}

"""primary key columns input for table: circle"""
input circle_pk_columns_input {
  id: uuid!
}

"""
select columns of table "circle"
"""
enum circle_select_column {
  """column name"""
  archived

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  parentId

  """column name"""
  roleId
}

"""
select "circle_aggregate_bool_exp_bool_and_arguments_columns" columns of table "circle"
"""
enum circle_select_column_circle_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived
}

"""
select "circle_aggregate_bool_exp_bool_or_arguments_columns" columns of table "circle"
"""
enum circle_select_column_circle_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived
}

"""
input type for updating data in table "circle"
"""
input circle_set_input {
  archived: Boolean
  id: uuid
  orgId: uuid
  parentId: uuid
  roleId: uuid
}

"""
Streaming cursor of the table "circle"
"""
input circle_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: circle_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input circle_stream_cursor_value_input {
  archived: Boolean
  id: uuid
  orgId: uuid
  parentId: uuid
  roleId: uuid
}

"""
update columns of table "circle"
"""
enum circle_update_column {
  """column name"""
  archived

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  parentId

  """column name"""
  roleId
}

input circle_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: circle_set_input
  where: circle_bool_exp!
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "decision"
"""
type decision {
  archived: Boolean!

  """An object relationship"""
  circle: circle!
  circleId: uuid!
  createdAt: timestamptz!
  description: String!
  id: uuid!

  """An object relationship"""
  member: member!
  memberId: uuid!

  """An object relationship"""
  org: org!
  orgId: uuid!
  title: String!
}

"""
aggregated selection of "decision"
"""
type decision_aggregate {
  aggregate: decision_aggregate_fields
  nodes: [decision!]!
}

input decision_aggregate_bool_exp {
  bool_and: decision_aggregate_bool_exp_bool_and
  bool_or: decision_aggregate_bool_exp_bool_or
  count: decision_aggregate_bool_exp_count
}

input decision_aggregate_bool_exp_bool_and {
  arguments: decision_select_column_decision_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: decision_bool_exp
  predicate: Boolean_comparison_exp!
}

input decision_aggregate_bool_exp_bool_or {
  arguments: decision_select_column_decision_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: decision_bool_exp
  predicate: Boolean_comparison_exp!
}

input decision_aggregate_bool_exp_count {
  arguments: [decision_select_column!]
  distinct: Boolean
  filter: decision_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "decision"
"""
type decision_aggregate_fields {
  count(columns: [decision_select_column!], distinct: Boolean): Int!
  max: decision_max_fields
  min: decision_min_fields
}

"""
order by aggregate values of table "decision"
"""
input decision_aggregate_order_by {
  count: order_by
  max: decision_max_order_by
  min: decision_min_order_by
}

"""
input type for inserting array relation for remote table "decision"
"""
input decision_arr_rel_insert_input {
  data: [decision_insert_input!]!

  """upsert condition"""
  on_conflict: decision_on_conflict
}

"""
Boolean expression to filter rows from the table "decision". All fields are combined with a logical 'AND'.
"""
input decision_bool_exp {
  _and: [decision_bool_exp!]
  _not: decision_bool_exp
  _or: [decision_bool_exp!]
  archived: Boolean_comparison_exp
  circle: circle_bool_exp
  circleId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  member: member_bool_exp
  memberId: uuid_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "decision"
"""
enum decision_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  decision_pkey
}

"""
input type for inserting data into table "decision"
"""
input decision_insert_input {
  archived: Boolean
  circle: circle_obj_rel_insert_input
  circleId: uuid
  createdAt: timestamptz
  description: String
  id: uuid
  member: member_obj_rel_insert_input
  memberId: uuid
  org: org_obj_rel_insert_input
  orgId: uuid
  title: String
}

"""aggregate max on columns"""
type decision_max_fields {
  circleId: uuid
  createdAt: timestamptz
  description: String
  id: uuid
  memberId: uuid
  orgId: uuid
  title: String
}

"""
order by max() on columns of table "decision"
"""
input decision_max_order_by {
  circleId: order_by
  createdAt: order_by
  description: order_by
  id: order_by
  memberId: order_by
  orgId: order_by
  title: order_by
}

"""aggregate min on columns"""
type decision_min_fields {
  circleId: uuid
  createdAt: timestamptz
  description: String
  id: uuid
  memberId: uuid
  orgId: uuid
  title: String
}

"""
order by min() on columns of table "decision"
"""
input decision_min_order_by {
  circleId: order_by
  createdAt: order_by
  description: order_by
  id: order_by
  memberId: order_by
  orgId: order_by
  title: order_by
}

"""
response of any mutation on the table "decision"
"""
type decision_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [decision!]!
}

"""
on_conflict condition type for table "decision"
"""
input decision_on_conflict {
  constraint: decision_constraint!
  update_columns: [decision_update_column!]! = []
  where: decision_bool_exp
}

"""Ordering options when selecting data from "decision"."""
input decision_order_by {
  archived: order_by
  circle: circle_order_by
  circleId: order_by
  createdAt: order_by
  description: order_by
  id: order_by
  member: member_order_by
  memberId: order_by
  org: org_order_by
  orgId: order_by
  title: order_by
}

"""primary key columns input for table: decision"""
input decision_pk_columns_input {
  id: uuid!
}

"""
select columns of table "decision"
"""
enum decision_select_column {
  """column name"""
  archived

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  memberId

  """column name"""
  orgId

  """column name"""
  title
}

"""
select "decision_aggregate_bool_exp_bool_and_arguments_columns" columns of table "decision"
"""
enum decision_select_column_decision_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived
}

"""
select "decision_aggregate_bool_exp_bool_or_arguments_columns" columns of table "decision"
"""
enum decision_select_column_decision_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived
}

"""
input type for updating data in table "decision"
"""
input decision_set_input {
  archived: Boolean
  circleId: uuid
  createdAt: timestamptz
  description: String
  id: uuid
  memberId: uuid
  orgId: uuid
  title: String
}

"""
Streaming cursor of the table "decision"
"""
input decision_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: decision_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input decision_stream_cursor_value_input {
  archived: Boolean
  circleId: uuid
  createdAt: timestamptz
  description: String
  id: uuid
  memberId: uuid
  orgId: uuid
  title: String
}

"""
update columns of table "decision"
"""
enum decision_update_column {
  """column name"""
  archived

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  memberId

  """column name"""
  orgId

  """column name"""
  title
}

input decision_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: decision_set_input
  where: decision_bool_exp!
}

"""
columns and relationships of "storage.files"
"""
type files {
  """An object relationship"""
  bucket: buckets!
  bucketId: String!
  createdAt: timestamptz!
  etag: String
  id: uuid!
  isUploaded: Boolean

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!
  mimeType: String
  name: String

  """An array relationship"""
  orgs(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): [org_file!]!

  """An aggregate relationship"""
  orgs_aggregate(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): org_file_aggregate!
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
aggregated selection of "storage.files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

input files_aggregate_bool_exp {
  bool_and: files_aggregate_bool_exp_bool_and
  bool_or: files_aggregate_bool_exp_bool_or
  count: files_aggregate_bool_exp_count
}

input files_aggregate_bool_exp_bool_and {
  arguments: files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_bool_or {
  arguments: files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_count {
  arguments: [files_select_column!]
  distinct: Boolean
  filter: files_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "storage.files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""
input type for inserting array relation for remote table "storage.files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "storage.files"
"""
input files_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucket: buckets_bool_exp
  bucketId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  members: member_bool_exp
  members_aggregate: member_aggregate_bool_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  orgs: org_file_bool_exp
  orgs_aggregate: org_file_aggregate_bool_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "storage.files"
"""
input files_inc_input {
  size: Int
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucket: buckets_obj_rel_insert_input
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  members: member_arr_rel_insert_input
  mimeType: String
  name: String
  orgs: org_file_arr_rel_insert_input
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by max() on columns of table "storage.files"
"""
input files_max_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by min() on columns of table "storage.files"
"""
input files_min_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "storage.files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucket: buckets_order_by
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  isUploaded: order_by
  members_aggregate: member_aggregate_order_by
  mimeType: order_by
  name: order_by
  orgs_aggregate: org_file_aggregate_order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""primary key columns input for table: storage.files"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
select "files_aggregate_bool_exp_bool_and_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isUploaded
}

"""
select "files_aggregate_bool_exp_bool_or_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isUploaded
}

"""
input type for updating data in table "storage.files"
"""
input files_set_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "storage.files"
"""
input files_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.files"
"""
input files_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.files"
"""
input files_stddev_samp_order_by {
  size: order_by
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate sum on columns"""
type files_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "storage.files"
"""
input files_sum_order_by {
  size: order_by
}

"""
update columns of table "storage.files"
"""
enum files_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

input files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "storage.files"
"""
input files_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "storage.files"
"""
input files_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "storage.files"
"""
input files_variance_order_by {
  size: order_by
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "log"
"""
type log {
  """An object relationship"""
  cancelLog: log

  """Id of canceled log, if it's a cancellation"""
  cancelLogId: uuid

  """An object relationship"""
  cancelMember: member

  """Member that did the action that's canceled"""
  cancelMemberId: uuid
  cancelMemberName: String
  canceled: Boolean!

  """Log of changes to entities, useful to cancel"""
  changes(
    """JSON select path"""
    path: String
  ): json!
  createdAt: timestamptz!

  """Type of log and data to display"""
  display(
    """JSON select path"""
    path: String
  ): json!
  id: uuid!

  """Meeting during which this log was created (optional)"""
  meetingId: uuid

  """An object relationship"""
  member: member!
  memberId: uuid!

  """Keep name for display, in case of deleted member"""
  memberName: String!

  """An object relationship"""
  org: org!
  orgId: uuid!

  """An object relationship"""
  user: users!

  """User and member who made the change"""
  userId: uuid!
}

"""
aggregated selection of "log"
"""
type log_aggregate {
  aggregate: log_aggregate_fields
  nodes: [log!]!
}

input log_aggregate_bool_exp {
  bool_and: log_aggregate_bool_exp_bool_and
  bool_or: log_aggregate_bool_exp_bool_or
  count: log_aggregate_bool_exp_count
}

input log_aggregate_bool_exp_bool_and {
  arguments: log_select_column_log_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: log_bool_exp
  predicate: Boolean_comparison_exp!
}

input log_aggregate_bool_exp_bool_or {
  arguments: log_select_column_log_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: log_bool_exp
  predicate: Boolean_comparison_exp!
}

input log_aggregate_bool_exp_count {
  arguments: [log_select_column!]
  distinct: Boolean
  filter: log_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "log"
"""
type log_aggregate_fields {
  count(columns: [log_select_column!], distinct: Boolean): Int!
  max: log_max_fields
  min: log_min_fields
}

"""
order by aggregate values of table "log"
"""
input log_aggregate_order_by {
  count: order_by
  max: log_max_order_by
  min: log_min_order_by
}

"""
input type for inserting array relation for remote table "log"
"""
input log_arr_rel_insert_input {
  data: [log_insert_input!]!

  """upsert condition"""
  on_conflict: log_on_conflict
}

"""
Boolean expression to filter rows from the table "log". All fields are combined with a logical 'AND'.
"""
input log_bool_exp {
  _and: [log_bool_exp!]
  _not: log_bool_exp
  _or: [log_bool_exp!]
  cancelLog: log_bool_exp
  cancelLogId: uuid_comparison_exp
  cancelMember: member_bool_exp
  cancelMemberId: uuid_comparison_exp
  cancelMemberName: String_comparison_exp
  canceled: Boolean_comparison_exp
  changes: json_comparison_exp
  createdAt: timestamptz_comparison_exp
  display: json_comparison_exp
  id: uuid_comparison_exp
  meetingId: uuid_comparison_exp
  member: member_bool_exp
  memberId: uuid_comparison_exp
  memberName: String_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "log"
"""
enum log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  log_pkey
}

"""
input type for inserting data into table "log"
"""
input log_insert_input {
  cancelLog: log_obj_rel_insert_input

  """Id of canceled log, if it's a cancellation"""
  cancelLogId: uuid
  cancelMember: member_obj_rel_insert_input

  """Member that did the action that's canceled"""
  cancelMemberId: uuid
  cancelMemberName: String
  canceled: Boolean

  """Log of changes to entities, useful to cancel"""
  changes: json
  createdAt: timestamptz

  """Type of log and data to display"""
  display: json
  id: uuid

  """Meeting during which this log was created (optional)"""
  meetingId: uuid
  member: member_obj_rel_insert_input
  memberId: uuid

  """Keep name for display, in case of deleted member"""
  memberName: String
  org: org_obj_rel_insert_input
  orgId: uuid
  user: users_obj_rel_insert_input

  """User and member who made the change"""
  userId: uuid
}

"""aggregate max on columns"""
type log_max_fields {
  """Id of canceled log, if it's a cancellation"""
  cancelLogId: uuid

  """Member that did the action that's canceled"""
  cancelMemberId: uuid
  cancelMemberName: String
  createdAt: timestamptz
  id: uuid

  """Meeting during which this log was created (optional)"""
  meetingId: uuid
  memberId: uuid

  """Keep name for display, in case of deleted member"""
  memberName: String
  orgId: uuid

  """User and member who made the change"""
  userId: uuid
}

"""
order by max() on columns of table "log"
"""
input log_max_order_by {
  """Id of canceled log, if it's a cancellation"""
  cancelLogId: order_by

  """Member that did the action that's canceled"""
  cancelMemberId: order_by
  cancelMemberName: order_by
  createdAt: order_by
  id: order_by

  """Meeting during which this log was created (optional)"""
  meetingId: order_by
  memberId: order_by

  """Keep name for display, in case of deleted member"""
  memberName: order_by
  orgId: order_by

  """User and member who made the change"""
  userId: order_by
}

"""aggregate min on columns"""
type log_min_fields {
  """Id of canceled log, if it's a cancellation"""
  cancelLogId: uuid

  """Member that did the action that's canceled"""
  cancelMemberId: uuid
  cancelMemberName: String
  createdAt: timestamptz
  id: uuid

  """Meeting during which this log was created (optional)"""
  meetingId: uuid
  memberId: uuid

  """Keep name for display, in case of deleted member"""
  memberName: String
  orgId: uuid

  """User and member who made the change"""
  userId: uuid
}

"""
order by min() on columns of table "log"
"""
input log_min_order_by {
  """Id of canceled log, if it's a cancellation"""
  cancelLogId: order_by

  """Member that did the action that's canceled"""
  cancelMemberId: order_by
  cancelMemberName: order_by
  createdAt: order_by
  id: order_by

  """Meeting during which this log was created (optional)"""
  meetingId: order_by
  memberId: order_by

  """Keep name for display, in case of deleted member"""
  memberName: order_by
  orgId: order_by

  """User and member who made the change"""
  userId: order_by
}

"""
response of any mutation on the table "log"
"""
type log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [log!]!
}

"""
input type for inserting object relation for remote table "log"
"""
input log_obj_rel_insert_input {
  data: log_insert_input!

  """upsert condition"""
  on_conflict: log_on_conflict
}

"""
on_conflict condition type for table "log"
"""
input log_on_conflict {
  constraint: log_constraint!
  update_columns: [log_update_column!]! = []
  where: log_bool_exp
}

"""Ordering options when selecting data from "log"."""
input log_order_by {
  cancelLog: log_order_by
  cancelLogId: order_by
  cancelMember: member_order_by
  cancelMemberId: order_by
  cancelMemberName: order_by
  canceled: order_by
  changes: order_by
  createdAt: order_by
  display: order_by
  id: order_by
  meetingId: order_by
  member: member_order_by
  memberId: order_by
  memberName: order_by
  org: org_order_by
  orgId: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: log"""
input log_pk_columns_input {
  id: uuid!
}

"""
select columns of table "log"
"""
enum log_select_column {
  """column name"""
  cancelLogId

  """column name"""
  cancelMemberId

  """column name"""
  cancelMemberName

  """column name"""
  canceled

  """column name"""
  changes

  """column name"""
  createdAt

  """column name"""
  display

  """column name"""
  id

  """column name"""
  meetingId

  """column name"""
  memberId

  """column name"""
  memberName

  """column name"""
  orgId

  """column name"""
  userId
}

"""
select "log_aggregate_bool_exp_bool_and_arguments_columns" columns of table "log"
"""
enum log_select_column_log_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  canceled
}

"""
select "log_aggregate_bool_exp_bool_or_arguments_columns" columns of table "log"
"""
enum log_select_column_log_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  canceled
}

"""
input type for updating data in table "log"
"""
input log_set_input {
  """Id of canceled log, if it's a cancellation"""
  cancelLogId: uuid

  """Member that did the action that's canceled"""
  cancelMemberId: uuid
  cancelMemberName: String
  canceled: Boolean

  """Log of changes to entities, useful to cancel"""
  changes: json
  createdAt: timestamptz

  """Type of log and data to display"""
  display: json
  id: uuid

  """Meeting during which this log was created (optional)"""
  meetingId: uuid
  memberId: uuid

  """Keep name for display, in case of deleted member"""
  memberName: String
  orgId: uuid

  """User and member who made the change"""
  userId: uuid
}

"""
Streaming cursor of the table "log"
"""
input log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input log_stream_cursor_value_input {
  """Id of canceled log, if it's a cancellation"""
  cancelLogId: uuid

  """Member that did the action that's canceled"""
  cancelMemberId: uuid
  cancelMemberName: String
  canceled: Boolean

  """Log of changes to entities, useful to cancel"""
  changes: json
  createdAt: timestamptz

  """Type of log and data to display"""
  display: json
  id: uuid

  """Meeting during which this log was created (optional)"""
  meetingId: uuid
  memberId: uuid

  """Keep name for display, in case of deleted member"""
  memberName: String
  orgId: uuid

  """User and member who made the change"""
  userId: uuid
}

"""
update columns of table "log"
"""
enum log_update_column {
  """column name"""
  cancelLogId

  """column name"""
  cancelMemberId

  """column name"""
  cancelMemberName

  """column name"""
  canceled

  """column name"""
  changes

  """column name"""
  createdAt

  """column name"""
  display

  """column name"""
  id

  """column name"""
  meetingId

  """column name"""
  memberId

  """column name"""
  memberName

  """column name"""
  orgId

  """column name"""
  userId
}

input log_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: log_set_input
  where: log_bool_exp!
}

"""
columns and relationships of "meeting"
"""
type meeting {
  archived: Boolean!
  attendees(
    """JSON select path"""
    path: String
  ): json

  """An object relationship"""
  circle: circle!
  circleId: uuid!
  createdAt: timestamptz!
  currentStepId: uuid
  endDate: timestamptz!
  ended: Boolean!
  id: uuid!

  """An object relationship"""
  org: org!
  orgId: uuid!
  participantsMembersIds(
    """JSON select path"""
    path: String
  ): json!
  participantsScope: member_scope_enum!

  """An object relationship"""
  recurring: meeting_recurring
  recurringDate: timestamptz
  recurringId: uuid
  startDate: timestamptz!

  """An array relationship"""
  steps(
    """distinct select on columns"""
    distinct_on: [meeting_step_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_order_by!]

    """filter the rows returned"""
    where: meeting_step_bool_exp
  ): [meeting_step!]!
  stepsConfig(
    """JSON select path"""
    path: String
  ): json!

  """An aggregate relationship"""
  steps_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_step_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_order_by!]

    """filter the rows returned"""
    where: meeting_step_bool_exp
  ): meeting_step_aggregate!
  title: String!
  videoConf(
    """JSON select path"""
    path: String
  ): json
}

"""
aggregated selection of "meeting"
"""
type meeting_aggregate {
  aggregate: meeting_aggregate_fields
  nodes: [meeting!]!
}

input meeting_aggregate_bool_exp {
  bool_and: meeting_aggregate_bool_exp_bool_and
  bool_or: meeting_aggregate_bool_exp_bool_or
  count: meeting_aggregate_bool_exp_count
}

input meeting_aggregate_bool_exp_bool_and {
  arguments: meeting_select_column_meeting_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: meeting_bool_exp
  predicate: Boolean_comparison_exp!
}

input meeting_aggregate_bool_exp_bool_or {
  arguments: meeting_select_column_meeting_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: meeting_bool_exp
  predicate: Boolean_comparison_exp!
}

input meeting_aggregate_bool_exp_count {
  arguments: [meeting_select_column!]
  distinct: Boolean
  filter: meeting_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "meeting"
"""
type meeting_aggregate_fields {
  count(columns: [meeting_select_column!], distinct: Boolean): Int!
  max: meeting_max_fields
  min: meeting_min_fields
}

"""
order by aggregate values of table "meeting"
"""
input meeting_aggregate_order_by {
  count: order_by
  max: meeting_max_order_by
  min: meeting_min_order_by
}

"""
input type for inserting array relation for remote table "meeting"
"""
input meeting_arr_rel_insert_input {
  data: [meeting_insert_input!]!

  """upsert condition"""
  on_conflict: meeting_on_conflict
}

"""
Boolean expression to filter rows from the table "meeting". All fields are combined with a logical 'AND'.
"""
input meeting_bool_exp {
  _and: [meeting_bool_exp!]
  _not: meeting_bool_exp
  _or: [meeting_bool_exp!]
  archived: Boolean_comparison_exp
  attendees: json_comparison_exp
  circle: circle_bool_exp
  circleId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  currentStepId: uuid_comparison_exp
  endDate: timestamptz_comparison_exp
  ended: Boolean_comparison_exp
  id: uuid_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  participantsMembersIds: json_comparison_exp
  participantsScope: member_scope_enum_comparison_exp
  recurring: meeting_recurring_bool_exp
  recurringDate: timestamptz_comparison_exp
  recurringId: uuid_comparison_exp
  startDate: timestamptz_comparison_exp
  steps: meeting_step_bool_exp
  stepsConfig: json_comparison_exp
  steps_aggregate: meeting_step_aggregate_bool_exp
  title: String_comparison_exp
  videoConf: json_comparison_exp
}

"""
unique or primary key constraints on table "meeting"
"""
enum meeting_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  meeting_pkey
}

"""
input type for inserting data into table "meeting"
"""
input meeting_insert_input {
  archived: Boolean
  attendees: json
  circle: circle_obj_rel_insert_input
  circleId: uuid
  createdAt: timestamptz
  currentStepId: uuid
  endDate: timestamptz
  ended: Boolean
  id: uuid
  org: org_obj_rel_insert_input
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  recurring: meeting_recurring_obj_rel_insert_input
  recurringDate: timestamptz
  recurringId: uuid
  startDate: timestamptz
  steps: meeting_step_arr_rel_insert_input
  stepsConfig: json
  title: String
  videoConf: json
}

"""aggregate max on columns"""
type meeting_max_fields {
  circleId: uuid
  createdAt: timestamptz
  currentStepId: uuid
  endDate: timestamptz
  id: uuid
  orgId: uuid
  recurringDate: timestamptz
  recurringId: uuid
  startDate: timestamptz
  title: String
}

"""
order by max() on columns of table "meeting"
"""
input meeting_max_order_by {
  circleId: order_by
  createdAt: order_by
  currentStepId: order_by
  endDate: order_by
  id: order_by
  orgId: order_by
  recurringDate: order_by
  recurringId: order_by
  startDate: order_by
  title: order_by
}

"""aggregate min on columns"""
type meeting_min_fields {
  circleId: uuid
  createdAt: timestamptz
  currentStepId: uuid
  endDate: timestamptz
  id: uuid
  orgId: uuid
  recurringDate: timestamptz
  recurringId: uuid
  startDate: timestamptz
  title: String
}

"""
order by min() on columns of table "meeting"
"""
input meeting_min_order_by {
  circleId: order_by
  createdAt: order_by
  currentStepId: order_by
  endDate: order_by
  id: order_by
  orgId: order_by
  recurringDate: order_by
  recurringId: order_by
  startDate: order_by
  title: order_by
}

"""
response of any mutation on the table "meeting"
"""
type meeting_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [meeting!]!
}

"""
input type for inserting object relation for remote table "meeting"
"""
input meeting_obj_rel_insert_input {
  data: meeting_insert_input!

  """upsert condition"""
  on_conflict: meeting_on_conflict
}

"""
on_conflict condition type for table "meeting"
"""
input meeting_on_conflict {
  constraint: meeting_constraint!
  update_columns: [meeting_update_column!]! = []
  where: meeting_bool_exp
}

"""Ordering options when selecting data from "meeting"."""
input meeting_order_by {
  archived: order_by
  attendees: order_by
  circle: circle_order_by
  circleId: order_by
  createdAt: order_by
  currentStepId: order_by
  endDate: order_by
  ended: order_by
  id: order_by
  org: org_order_by
  orgId: order_by
  participantsMembersIds: order_by
  participantsScope: order_by
  recurring: meeting_recurring_order_by
  recurringDate: order_by
  recurringId: order_by
  startDate: order_by
  stepsConfig: order_by
  steps_aggregate: meeting_step_aggregate_order_by
  title: order_by
  videoConf: order_by
}

"""primary key columns input for table: meeting"""
input meeting_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "meeting_recurring"
"""
type meeting_recurring {
  """An object relationship"""
  circle: circle!
  circleId: uuid!
  createdAt: timestamptz!
  duration: smallint!
  id: uuid!

  """An array relationship"""
  meetings(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): [meeting!]!

  """An aggregate relationship"""
  meetings_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): meeting_aggregate!

  """An object relationship"""
  org: org!
  orgId: uuid!
  participantsMembersIds(
    """JSON select path"""
    path: String
  ): json!
  participantsScope: member_scope_enum!
  rrule: String!

  """An object relationship"""
  template: meeting_template!
  templateId: uuid!
  videoConf(
    """JSON select path"""
    path: String
  ): json
}

"""
aggregated selection of "meeting_recurring"
"""
type meeting_recurring_aggregate {
  aggregate: meeting_recurring_aggregate_fields
  nodes: [meeting_recurring!]!
}

input meeting_recurring_aggregate_bool_exp {
  count: meeting_recurring_aggregate_bool_exp_count
}

input meeting_recurring_aggregate_bool_exp_count {
  arguments: [meeting_recurring_select_column!]
  distinct: Boolean
  filter: meeting_recurring_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "meeting_recurring"
"""
type meeting_recurring_aggregate_fields {
  avg: meeting_recurring_avg_fields
  count(columns: [meeting_recurring_select_column!], distinct: Boolean): Int!
  max: meeting_recurring_max_fields
  min: meeting_recurring_min_fields
  stddev: meeting_recurring_stddev_fields
  stddev_pop: meeting_recurring_stddev_pop_fields
  stddev_samp: meeting_recurring_stddev_samp_fields
  sum: meeting_recurring_sum_fields
  var_pop: meeting_recurring_var_pop_fields
  var_samp: meeting_recurring_var_samp_fields
  variance: meeting_recurring_variance_fields
}

"""
order by aggregate values of table "meeting_recurring"
"""
input meeting_recurring_aggregate_order_by {
  avg: meeting_recurring_avg_order_by
  count: order_by
  max: meeting_recurring_max_order_by
  min: meeting_recurring_min_order_by
  stddev: meeting_recurring_stddev_order_by
  stddev_pop: meeting_recurring_stddev_pop_order_by
  stddev_samp: meeting_recurring_stddev_samp_order_by
  sum: meeting_recurring_sum_order_by
  var_pop: meeting_recurring_var_pop_order_by
  var_samp: meeting_recurring_var_samp_order_by
  variance: meeting_recurring_variance_order_by
}

"""
input type for inserting array relation for remote table "meeting_recurring"
"""
input meeting_recurring_arr_rel_insert_input {
  data: [meeting_recurring_insert_input!]!

  """upsert condition"""
  on_conflict: meeting_recurring_on_conflict
}

"""aggregate avg on columns"""
type meeting_recurring_avg_fields {
  duration: Float
}

"""
order by avg() on columns of table "meeting_recurring"
"""
input meeting_recurring_avg_order_by {
  duration: order_by
}

"""
Boolean expression to filter rows from the table "meeting_recurring". All fields are combined with a logical 'AND'.
"""
input meeting_recurring_bool_exp {
  _and: [meeting_recurring_bool_exp!]
  _not: meeting_recurring_bool_exp
  _or: [meeting_recurring_bool_exp!]
  circle: circle_bool_exp
  circleId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  duration: smallint_comparison_exp
  id: uuid_comparison_exp
  meetings: meeting_bool_exp
  meetings_aggregate: meeting_aggregate_bool_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  participantsMembersIds: json_comparison_exp
  participantsScope: member_scope_enum_comparison_exp
  rrule: String_comparison_exp
  template: meeting_template_bool_exp
  templateId: uuid_comparison_exp
  videoConf: json_comparison_exp
}

"""
unique or primary key constraints on table "meeting_recurring"
"""
enum meeting_recurring_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  meeting_recurring_pkey
}

"""
input type for incrementing numeric columns in table "meeting_recurring"
"""
input meeting_recurring_inc_input {
  duration: smallint
}

"""
input type for inserting data into table "meeting_recurring"
"""
input meeting_recurring_insert_input {
  circle: circle_obj_rel_insert_input
  circleId: uuid
  createdAt: timestamptz
  duration: smallint
  id: uuid
  meetings: meeting_arr_rel_insert_input
  org: org_obj_rel_insert_input
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  rrule: String
  template: meeting_template_obj_rel_insert_input
  templateId: uuid
  videoConf: json
}

"""aggregate max on columns"""
type meeting_recurring_max_fields {
  circleId: uuid
  createdAt: timestamptz
  duration: smallint
  id: uuid
  orgId: uuid
  rrule: String
  templateId: uuid
}

"""
order by max() on columns of table "meeting_recurring"
"""
input meeting_recurring_max_order_by {
  circleId: order_by
  createdAt: order_by
  duration: order_by
  id: order_by
  orgId: order_by
  rrule: order_by
  templateId: order_by
}

"""aggregate min on columns"""
type meeting_recurring_min_fields {
  circleId: uuid
  createdAt: timestamptz
  duration: smallint
  id: uuid
  orgId: uuid
  rrule: String
  templateId: uuid
}

"""
order by min() on columns of table "meeting_recurring"
"""
input meeting_recurring_min_order_by {
  circleId: order_by
  createdAt: order_by
  duration: order_by
  id: order_by
  orgId: order_by
  rrule: order_by
  templateId: order_by
}

"""
response of any mutation on the table "meeting_recurring"
"""
type meeting_recurring_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [meeting_recurring!]!
}

"""
input type for inserting object relation for remote table "meeting_recurring"
"""
input meeting_recurring_obj_rel_insert_input {
  data: meeting_recurring_insert_input!

  """upsert condition"""
  on_conflict: meeting_recurring_on_conflict
}

"""
on_conflict condition type for table "meeting_recurring"
"""
input meeting_recurring_on_conflict {
  constraint: meeting_recurring_constraint!
  update_columns: [meeting_recurring_update_column!]! = []
  where: meeting_recurring_bool_exp
}

"""Ordering options when selecting data from "meeting_recurring"."""
input meeting_recurring_order_by {
  circle: circle_order_by
  circleId: order_by
  createdAt: order_by
  duration: order_by
  id: order_by
  meetings_aggregate: meeting_aggregate_order_by
  org: org_order_by
  orgId: order_by
  participantsMembersIds: order_by
  participantsScope: order_by
  rrule: order_by
  template: meeting_template_order_by
  templateId: order_by
  videoConf: order_by
}

"""primary key columns input for table: meeting_recurring"""
input meeting_recurring_pk_columns_input {
  id: uuid!
}

"""
select columns of table "meeting_recurring"
"""
enum meeting_recurring_select_column {
  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  duration

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  participantsMembersIds

  """column name"""
  participantsScope

  """column name"""
  rrule

  """column name"""
  templateId

  """column name"""
  videoConf
}

"""
input type for updating data in table "meeting_recurring"
"""
input meeting_recurring_set_input {
  circleId: uuid
  createdAt: timestamptz
  duration: smallint
  id: uuid
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  rrule: String
  templateId: uuid
  videoConf: json
}

"""aggregate stddev on columns"""
type meeting_recurring_stddev_fields {
  duration: Float
}

"""
order by stddev() on columns of table "meeting_recurring"
"""
input meeting_recurring_stddev_order_by {
  duration: order_by
}

"""aggregate stddev_pop on columns"""
type meeting_recurring_stddev_pop_fields {
  duration: Float
}

"""
order by stddev_pop() on columns of table "meeting_recurring"
"""
input meeting_recurring_stddev_pop_order_by {
  duration: order_by
}

"""aggregate stddev_samp on columns"""
type meeting_recurring_stddev_samp_fields {
  duration: Float
}

"""
order by stddev_samp() on columns of table "meeting_recurring"
"""
input meeting_recurring_stddev_samp_order_by {
  duration: order_by
}

"""
Streaming cursor of the table "meeting_recurring"
"""
input meeting_recurring_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: meeting_recurring_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input meeting_recurring_stream_cursor_value_input {
  circleId: uuid
  createdAt: timestamptz
  duration: smallint
  id: uuid
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  rrule: String
  templateId: uuid
  videoConf: json
}

"""aggregate sum on columns"""
type meeting_recurring_sum_fields {
  duration: smallint
}

"""
order by sum() on columns of table "meeting_recurring"
"""
input meeting_recurring_sum_order_by {
  duration: order_by
}

"""
update columns of table "meeting_recurring"
"""
enum meeting_recurring_update_column {
  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  duration

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  participantsMembersIds

  """column name"""
  participantsScope

  """column name"""
  rrule

  """column name"""
  templateId

  """column name"""
  videoConf
}

input meeting_recurring_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: meeting_recurring_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: meeting_recurring_set_input
  where: meeting_recurring_bool_exp!
}

"""aggregate var_pop on columns"""
type meeting_recurring_var_pop_fields {
  duration: Float
}

"""
order by var_pop() on columns of table "meeting_recurring"
"""
input meeting_recurring_var_pop_order_by {
  duration: order_by
}

"""aggregate var_samp on columns"""
type meeting_recurring_var_samp_fields {
  duration: Float
}

"""
order by var_samp() on columns of table "meeting_recurring"
"""
input meeting_recurring_var_samp_order_by {
  duration: order_by
}

"""aggregate variance on columns"""
type meeting_recurring_variance_fields {
  duration: Float
}

"""
order by variance() on columns of table "meeting_recurring"
"""
input meeting_recurring_variance_order_by {
  duration: order_by
}

"""
select columns of table "meeting"
"""
enum meeting_select_column {
  """column name"""
  archived

  """column name"""
  attendees

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  currentStepId

  """column name"""
  endDate

  """column name"""
  ended

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  participantsMembersIds

  """column name"""
  participantsScope

  """column name"""
  recurringDate

  """column name"""
  recurringId

  """column name"""
  startDate

  """column name"""
  stepsConfig

  """column name"""
  title

  """column name"""
  videoConf
}

"""
select "meeting_aggregate_bool_exp_bool_and_arguments_columns" columns of table "meeting"
"""
enum meeting_select_column_meeting_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived

  """column name"""
  ended
}

"""
select "meeting_aggregate_bool_exp_bool_or_arguments_columns" columns of table "meeting"
"""
enum meeting_select_column_meeting_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived

  """column name"""
  ended
}

"""
input type for updating data in table "meeting"
"""
input meeting_set_input {
  archived: Boolean
  attendees: json
  circleId: uuid
  createdAt: timestamptz
  currentStepId: uuid
  endDate: timestamptz
  ended: Boolean
  id: uuid
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  recurringDate: timestamptz
  recurringId: uuid
  startDate: timestamptz
  stepsConfig: json
  title: String
  videoConf: json
}

"""
columns and relationships of "meeting_stats"
"""
type meeting_stats {
  count: bigint
  day: timestamptz
  orgId: uuid
}

"""
aggregated selection of "meeting_stats"
"""
type meeting_stats_aggregate {
  aggregate: meeting_stats_aggregate_fields
  nodes: [meeting_stats!]!
}

"""
aggregate fields of "meeting_stats"
"""
type meeting_stats_aggregate_fields {
  avg: meeting_stats_avg_fields
  count(columns: [meeting_stats_select_column!], distinct: Boolean): Int!
  max: meeting_stats_max_fields
  min: meeting_stats_min_fields
  stddev: meeting_stats_stddev_fields
  stddev_pop: meeting_stats_stddev_pop_fields
  stddev_samp: meeting_stats_stddev_samp_fields
  sum: meeting_stats_sum_fields
  var_pop: meeting_stats_var_pop_fields
  var_samp: meeting_stats_var_samp_fields
  variance: meeting_stats_variance_fields
}

"""aggregate avg on columns"""
type meeting_stats_avg_fields {
  count: Float
}

"""
Boolean expression to filter rows from the table "meeting_stats". All fields are combined with a logical 'AND'.
"""
input meeting_stats_bool_exp {
  _and: [meeting_stats_bool_exp!]
  _not: meeting_stats_bool_exp
  _or: [meeting_stats_bool_exp!]
  count: bigint_comparison_exp
  day: timestamptz_comparison_exp
  orgId: uuid_comparison_exp
}

"""aggregate max on columns"""
type meeting_stats_max_fields {
  count: bigint
  day: timestamptz
  orgId: uuid
}

"""aggregate min on columns"""
type meeting_stats_min_fields {
  count: bigint
  day: timestamptz
  orgId: uuid
}

"""Ordering options when selecting data from "meeting_stats"."""
input meeting_stats_order_by {
  count: order_by
  day: order_by
  orgId: order_by
}

"""
select columns of table "meeting_stats"
"""
enum meeting_stats_select_column {
  """column name"""
  count

  """column name"""
  day

  """column name"""
  orgId
}

"""aggregate stddev on columns"""
type meeting_stats_stddev_fields {
  count: Float
}

"""aggregate stddev_pop on columns"""
type meeting_stats_stddev_pop_fields {
  count: Float
}

"""aggregate stddev_samp on columns"""
type meeting_stats_stddev_samp_fields {
  count: Float
}

"""
Streaming cursor of the table "meeting_stats"
"""
input meeting_stats_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: meeting_stats_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input meeting_stats_stream_cursor_value_input {
  count: bigint
  day: timestamptz
  orgId: uuid
}

"""aggregate sum on columns"""
type meeting_stats_sum_fields {
  count: bigint
}

"""aggregate var_pop on columns"""
type meeting_stats_var_pop_fields {
  count: Float
}

"""aggregate var_samp on columns"""
type meeting_stats_var_samp_fields {
  count: Float
}

"""aggregate variance on columns"""
type meeting_stats_variance_fields {
  count: Float
}

"""
columns and relationships of "meeting_step"
"""
type meeting_step {
  data(
    """JSON select path"""
    path: String
  ): json!
  id: uuid!

  """An object relationship"""
  meeting: meeting!
  meetingId: uuid!
  notes: String!
  stepConfigId: String!
  type: meeting_step_type_enum!
}

"""
aggregated selection of "meeting_step"
"""
type meeting_step_aggregate {
  aggregate: meeting_step_aggregate_fields
  nodes: [meeting_step!]!
}

input meeting_step_aggregate_bool_exp {
  count: meeting_step_aggregate_bool_exp_count
}

input meeting_step_aggregate_bool_exp_count {
  arguments: [meeting_step_select_column!]
  distinct: Boolean
  filter: meeting_step_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "meeting_step"
"""
type meeting_step_aggregate_fields {
  count(columns: [meeting_step_select_column!], distinct: Boolean): Int!
  max: meeting_step_max_fields
  min: meeting_step_min_fields
}

"""
order by aggregate values of table "meeting_step"
"""
input meeting_step_aggregate_order_by {
  count: order_by
  max: meeting_step_max_order_by
  min: meeting_step_min_order_by
}

"""
input type for inserting array relation for remote table "meeting_step"
"""
input meeting_step_arr_rel_insert_input {
  data: [meeting_step_insert_input!]!

  """upsert condition"""
  on_conflict: meeting_step_on_conflict
}

"""
Boolean expression to filter rows from the table "meeting_step". All fields are combined with a logical 'AND'.
"""
input meeting_step_bool_exp {
  _and: [meeting_step_bool_exp!]
  _not: meeting_step_bool_exp
  _or: [meeting_step_bool_exp!]
  data: json_comparison_exp
  id: uuid_comparison_exp
  meeting: meeting_bool_exp
  meetingId: uuid_comparison_exp
  notes: String_comparison_exp
  stepConfigId: String_comparison_exp
  type: meeting_step_type_enum_comparison_exp
}

"""
unique or primary key constraints on table "meeting_step"
"""
enum meeting_step_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  meeting_step_pkey
}

"""
input type for inserting data into table "meeting_step"
"""
input meeting_step_insert_input {
  data: json
  id: uuid
  meeting: meeting_obj_rel_insert_input
  meetingId: uuid
  notes: String
  stepConfigId: String
  type: meeting_step_type_enum
}

"""aggregate max on columns"""
type meeting_step_max_fields {
  id: uuid
  meetingId: uuid
  notes: String
  stepConfigId: String
}

"""
order by max() on columns of table "meeting_step"
"""
input meeting_step_max_order_by {
  id: order_by
  meetingId: order_by
  notes: order_by
  stepConfigId: order_by
}

"""aggregate min on columns"""
type meeting_step_min_fields {
  id: uuid
  meetingId: uuid
  notes: String
  stepConfigId: String
}

"""
order by min() on columns of table "meeting_step"
"""
input meeting_step_min_order_by {
  id: order_by
  meetingId: order_by
  notes: order_by
  stepConfigId: order_by
}

"""
response of any mutation on the table "meeting_step"
"""
type meeting_step_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [meeting_step!]!
}

"""
on_conflict condition type for table "meeting_step"
"""
input meeting_step_on_conflict {
  constraint: meeting_step_constraint!
  update_columns: [meeting_step_update_column!]! = []
  where: meeting_step_bool_exp
}

"""Ordering options when selecting data from "meeting_step"."""
input meeting_step_order_by {
  data: order_by
  id: order_by
  meeting: meeting_order_by
  meetingId: order_by
  notes: order_by
  stepConfigId: order_by
  type: order_by
}

"""primary key columns input for table: meeting_step"""
input meeting_step_pk_columns_input {
  id: uuid!
}

"""
select columns of table "meeting_step"
"""
enum meeting_step_select_column {
  """column name"""
  data

  """column name"""
  id

  """column name"""
  meetingId

  """column name"""
  notes

  """column name"""
  stepConfigId

  """column name"""
  type
}

"""
input type for updating data in table "meeting_step"
"""
input meeting_step_set_input {
  data: json
  id: uuid
  meetingId: uuid
  notes: String
  stepConfigId: String
  type: meeting_step_type_enum
}

"""
Streaming cursor of the table "meeting_step"
"""
input meeting_step_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: meeting_step_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input meeting_step_stream_cursor_value_input {
  data: json
  id: uuid
  meetingId: uuid
  notes: String
  stepConfigId: String
  type: meeting_step_type_enum
}

"""
columns and relationships of "meeting_step_type"
"""
type meeting_step_type {
  comment: String
  value: String!
}

"""
aggregated selection of "meeting_step_type"
"""
type meeting_step_type_aggregate {
  aggregate: meeting_step_type_aggregate_fields
  nodes: [meeting_step_type!]!
}

"""
aggregate fields of "meeting_step_type"
"""
type meeting_step_type_aggregate_fields {
  count(columns: [meeting_step_type_select_column!], distinct: Boolean): Int!
  max: meeting_step_type_max_fields
  min: meeting_step_type_min_fields
}

"""
Boolean expression to filter rows from the table "meeting_step_type". All fields are combined with a logical 'AND'.
"""
input meeting_step_type_bool_exp {
  _and: [meeting_step_type_bool_exp!]
  _not: meeting_step_type_bool_exp
  _or: [meeting_step_type_bool_exp!]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "meeting_step_type"
"""
enum meeting_step_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  meeting_step_type_pkey
}

enum meeting_step_type_enum {
  """"""
  Checklist

  """"""
  Indicators

  """"""
  Tasks

  """"""
  Threads

  """"""
  Tour
}

"""
Boolean expression to compare columns of type "meeting_step_type_enum". All fields are combined with logical 'AND'.
"""
input meeting_step_type_enum_comparison_exp {
  _eq: meeting_step_type_enum
  _in: [meeting_step_type_enum!]
  _is_null: Boolean
  _neq: meeting_step_type_enum
  _nin: [meeting_step_type_enum!]
}

"""
input type for inserting data into table "meeting_step_type"
"""
input meeting_step_type_insert_input {
  comment: String
  value: String
}

"""aggregate max on columns"""
type meeting_step_type_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type meeting_step_type_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "meeting_step_type"
"""
type meeting_step_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [meeting_step_type!]!
}

"""
on_conflict condition type for table "meeting_step_type"
"""
input meeting_step_type_on_conflict {
  constraint: meeting_step_type_constraint!
  update_columns: [meeting_step_type_update_column!]! = []
  where: meeting_step_type_bool_exp
}

"""Ordering options when selecting data from "meeting_step_type"."""
input meeting_step_type_order_by {
  comment: order_by
  value: order_by
}

"""primary key columns input for table: meeting_step_type"""
input meeting_step_type_pk_columns_input {
  value: String!
}

"""
select columns of table "meeting_step_type"
"""
enum meeting_step_type_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "meeting_step_type"
"""
input meeting_step_type_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "meeting_step_type"
"""
input meeting_step_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: meeting_step_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input meeting_step_type_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "meeting_step_type"
"""
enum meeting_step_type_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input meeting_step_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: meeting_step_type_set_input
  where: meeting_step_type_bool_exp!
}

"""
update columns of table "meeting_step"
"""
enum meeting_step_update_column {
  """column name"""
  data

  """column name"""
  id

  """column name"""
  meetingId

  """column name"""
  notes

  """column name"""
  stepConfigId

  """column name"""
  type
}

input meeting_step_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: meeting_step_set_input
  where: meeting_step_bool_exp!
}

"""
Streaming cursor of the table "meeting"
"""
input meeting_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: meeting_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input meeting_stream_cursor_value_input {
  archived: Boolean
  attendees: json
  circleId: uuid
  createdAt: timestamptz
  currentStepId: uuid
  endDate: timestamptz
  ended: Boolean
  id: uuid
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  recurringDate: timestamptz
  recurringId: uuid
  startDate: timestamptz
  stepsConfig: json
  title: String
  videoConf: json
}

"""
columns and relationships of "meeting_template"
"""
type meeting_template {
  id: uuid!

  """An object relationship"""
  org: org!
  orgId: uuid!
  stepsConfig(
    """JSON select path"""
    path: String
  ): json!
  title: String!
}

"""
aggregated selection of "meeting_template"
"""
type meeting_template_aggregate {
  aggregate: meeting_template_aggregate_fields
  nodes: [meeting_template!]!
}

input meeting_template_aggregate_bool_exp {
  count: meeting_template_aggregate_bool_exp_count
}

input meeting_template_aggregate_bool_exp_count {
  arguments: [meeting_template_select_column!]
  distinct: Boolean
  filter: meeting_template_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "meeting_template"
"""
type meeting_template_aggregate_fields {
  count(columns: [meeting_template_select_column!], distinct: Boolean): Int!
  max: meeting_template_max_fields
  min: meeting_template_min_fields
}

"""
order by aggregate values of table "meeting_template"
"""
input meeting_template_aggregate_order_by {
  count: order_by
  max: meeting_template_max_order_by
  min: meeting_template_min_order_by
}

"""
input type for inserting array relation for remote table "meeting_template"
"""
input meeting_template_arr_rel_insert_input {
  data: [meeting_template_insert_input!]!

  """upsert condition"""
  on_conflict: meeting_template_on_conflict
}

"""
Boolean expression to filter rows from the table "meeting_template". All fields are combined with a logical 'AND'.
"""
input meeting_template_bool_exp {
  _and: [meeting_template_bool_exp!]
  _not: meeting_template_bool_exp
  _or: [meeting_template_bool_exp!]
  id: uuid_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  stepsConfig: json_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "meeting_template"
"""
enum meeting_template_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  meeting_template_pkey
}

"""
input type for inserting data into table "meeting_template"
"""
input meeting_template_insert_input {
  id: uuid
  org: org_obj_rel_insert_input
  orgId: uuid
  stepsConfig: json
  title: String
}

"""aggregate max on columns"""
type meeting_template_max_fields {
  id: uuid
  orgId: uuid
  title: String
}

"""
order by max() on columns of table "meeting_template"
"""
input meeting_template_max_order_by {
  id: order_by
  orgId: order_by
  title: order_by
}

"""aggregate min on columns"""
type meeting_template_min_fields {
  id: uuid
  orgId: uuid
  title: String
}

"""
order by min() on columns of table "meeting_template"
"""
input meeting_template_min_order_by {
  id: order_by
  orgId: order_by
  title: order_by
}

"""
response of any mutation on the table "meeting_template"
"""
type meeting_template_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [meeting_template!]!
}

"""
input type for inserting object relation for remote table "meeting_template"
"""
input meeting_template_obj_rel_insert_input {
  data: meeting_template_insert_input!

  """upsert condition"""
  on_conflict: meeting_template_on_conflict
}

"""
on_conflict condition type for table "meeting_template"
"""
input meeting_template_on_conflict {
  constraint: meeting_template_constraint!
  update_columns: [meeting_template_update_column!]! = []
  where: meeting_template_bool_exp
}

"""Ordering options when selecting data from "meeting_template"."""
input meeting_template_order_by {
  id: order_by
  org: org_order_by
  orgId: order_by
  stepsConfig: order_by
  title: order_by
}

"""primary key columns input for table: meeting_template"""
input meeting_template_pk_columns_input {
  id: uuid!
}

"""
select columns of table "meeting_template"
"""
enum meeting_template_select_column {
  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  stepsConfig

  """column name"""
  title
}

"""
input type for updating data in table "meeting_template"
"""
input meeting_template_set_input {
  id: uuid
  orgId: uuid
  stepsConfig: json
  title: String
}

"""
Streaming cursor of the table "meeting_template"
"""
input meeting_template_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: meeting_template_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input meeting_template_stream_cursor_value_input {
  id: uuid
  orgId: uuid
  stepsConfig: json
  title: String
}

"""
update columns of table "meeting_template"
"""
enum meeting_template_update_column {
  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  stepsConfig

  """column name"""
  title
}

input meeting_template_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: meeting_template_set_input
  where: meeting_template_bool_exp!
}

"""
update columns of table "meeting"
"""
enum meeting_update_column {
  """column name"""
  archived

  """column name"""
  attendees

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  currentStepId

  """column name"""
  endDate

  """column name"""
  ended

  """column name"""
  id

  """column name"""
  orgId

  """column name"""
  participantsMembersIds

  """column name"""
  participantsScope

  """column name"""
  recurringDate

  """column name"""
  recurringId

  """column name"""
  startDate

  """column name"""
  stepsConfig

  """column name"""
  title

  """column name"""
  videoConf
}

input meeting_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: meeting_set_input
  where: meeting_bool_exp!
}

"""
columns and relationships of "member"
"""
type member {
  archived: Boolean!

  """An array relationship"""
  circle_members(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): [circle_member!]!

  """An aggregate relationship"""
  circle_members_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): circle_member_aggregate!
  description: String!
  id: uuid!
  inviteDate: timestamptz
  inviteEmail: String
  meetingId: uuid
  name: String!

  """An object relationship"""
  org: org!
  orgId: uuid!
  picture: String

  """An object relationship"""
  pictureFile: files
  pictureFileId: uuid
  preferences(
    """JSON select path"""
    path: String
  ): json
  role: member_role_enum

  """An object relationship"""
  user: users
  userId: uuid
  workedMinPerWeek: Int
}

"""
aggregated selection of "member"
"""
type member_aggregate {
  aggregate: member_aggregate_fields
  nodes: [member!]!
}

input member_aggregate_bool_exp {
  bool_and: member_aggregate_bool_exp_bool_and
  bool_or: member_aggregate_bool_exp_bool_or
  count: member_aggregate_bool_exp_count
}

input member_aggregate_bool_exp_bool_and {
  arguments: member_select_column_member_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: member_bool_exp
  predicate: Boolean_comparison_exp!
}

input member_aggregate_bool_exp_bool_or {
  arguments: member_select_column_member_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: member_bool_exp
  predicate: Boolean_comparison_exp!
}

input member_aggregate_bool_exp_count {
  arguments: [member_select_column!]
  distinct: Boolean
  filter: member_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "member"
"""
type member_aggregate_fields {
  avg: member_avg_fields
  count(columns: [member_select_column!], distinct: Boolean): Int!
  max: member_max_fields
  min: member_min_fields
  stddev: member_stddev_fields
  stddev_pop: member_stddev_pop_fields
  stddev_samp: member_stddev_samp_fields
  sum: member_sum_fields
  var_pop: member_var_pop_fields
  var_samp: member_var_samp_fields
  variance: member_variance_fields
}

"""
order by aggregate values of table "member"
"""
input member_aggregate_order_by {
  avg: member_avg_order_by
  count: order_by
  max: member_max_order_by
  min: member_min_order_by
  stddev: member_stddev_order_by
  stddev_pop: member_stddev_pop_order_by
  stddev_samp: member_stddev_samp_order_by
  sum: member_sum_order_by
  var_pop: member_var_pop_order_by
  var_samp: member_var_samp_order_by
  variance: member_variance_order_by
}

"""
input type for inserting array relation for remote table "member"
"""
input member_arr_rel_insert_input {
  data: [member_insert_input!]!

  """upsert condition"""
  on_conflict: member_on_conflict
}

"""aggregate avg on columns"""
type member_avg_fields {
  workedMinPerWeek: Float
}

"""
order by avg() on columns of table "member"
"""
input member_avg_order_by {
  workedMinPerWeek: order_by
}

"""
Boolean expression to filter rows from the table "member". All fields are combined with a logical 'AND'.
"""
input member_bool_exp {
  _and: [member_bool_exp!]
  _not: member_bool_exp
  _or: [member_bool_exp!]
  archived: Boolean_comparison_exp
  circle_members: circle_member_bool_exp
  circle_members_aggregate: circle_member_aggregate_bool_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  inviteDate: timestamptz_comparison_exp
  inviteEmail: String_comparison_exp
  meetingId: uuid_comparison_exp
  name: String_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  picture: String_comparison_exp
  pictureFile: files_bool_exp
  pictureFileId: uuid_comparison_exp
  preferences: json_comparison_exp
  role: member_role_enum_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
  workedMinPerWeek: Int_comparison_exp
}

"""
unique or primary key constraints on table "member"
"""
enum member_constraint {
  """
  unique or primary key constraint on columns "orgId", "userId"
  """
  member_orgId_userId_key

  """
  unique or primary key constraint on columns "id"
  """
  member_pkey
}

"""
input type for incrementing numeric columns in table "member"
"""
input member_inc_input {
  workedMinPerWeek: Int
}

"""
input type for inserting data into table "member"
"""
input member_insert_input {
  archived: Boolean
  circle_members: circle_member_arr_rel_insert_input
  description: String
  id: uuid
  inviteDate: timestamptz
  inviteEmail: String
  meetingId: uuid
  name: String
  org: org_obj_rel_insert_input
  orgId: uuid
  picture: String
  pictureFile: files_obj_rel_insert_input
  pictureFileId: uuid
  preferences: json
  role: member_role_enum
  user: users_obj_rel_insert_input
  userId: uuid
  workedMinPerWeek: Int
}

"""aggregate max on columns"""
type member_max_fields {
  description: String
  id: uuid
  inviteDate: timestamptz
  inviteEmail: String
  meetingId: uuid
  name: String
  orgId: uuid
  picture: String
  pictureFileId: uuid
  userId: uuid
  workedMinPerWeek: Int
}

"""
order by max() on columns of table "member"
"""
input member_max_order_by {
  description: order_by
  id: order_by
  inviteDate: order_by
  inviteEmail: order_by
  meetingId: order_by
  name: order_by
  orgId: order_by
  picture: order_by
  pictureFileId: order_by
  userId: order_by
  workedMinPerWeek: order_by
}

"""aggregate min on columns"""
type member_min_fields {
  description: String
  id: uuid
  inviteDate: timestamptz
  inviteEmail: String
  meetingId: uuid
  name: String
  orgId: uuid
  picture: String
  pictureFileId: uuid
  userId: uuid
  workedMinPerWeek: Int
}

"""
order by min() on columns of table "member"
"""
input member_min_order_by {
  description: order_by
  id: order_by
  inviteDate: order_by
  inviteEmail: order_by
  meetingId: order_by
  name: order_by
  orgId: order_by
  picture: order_by
  pictureFileId: order_by
  userId: order_by
  workedMinPerWeek: order_by
}

"""
response of any mutation on the table "member"
"""
type member_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [member!]!
}

"""
input type for inserting object relation for remote table "member"
"""
input member_obj_rel_insert_input {
  data: member_insert_input!

  """upsert condition"""
  on_conflict: member_on_conflict
}

"""
on_conflict condition type for table "member"
"""
input member_on_conflict {
  constraint: member_constraint!
  update_columns: [member_update_column!]! = []
  where: member_bool_exp
}

"""Ordering options when selecting data from "member"."""
input member_order_by {
  archived: order_by
  circle_members_aggregate: circle_member_aggregate_order_by
  description: order_by
  id: order_by
  inviteDate: order_by
  inviteEmail: order_by
  meetingId: order_by
  name: order_by
  org: org_order_by
  orgId: order_by
  picture: order_by
  pictureFile: files_order_by
  pictureFileId: order_by
  preferences: order_by
  role: order_by
  user: users_order_by
  userId: order_by
  workedMinPerWeek: order_by
}

"""primary key columns input for table: member"""
input member_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "member_role"
"""
type member_role {
  comment: String
  value: String!
}

"""
aggregated selection of "member_role"
"""
type member_role_aggregate {
  aggregate: member_role_aggregate_fields
  nodes: [member_role!]!
}

"""
aggregate fields of "member_role"
"""
type member_role_aggregate_fields {
  count(columns: [member_role_select_column!], distinct: Boolean): Int!
  max: member_role_max_fields
  min: member_role_min_fields
}

"""
Boolean expression to filter rows from the table "member_role". All fields are combined with a logical 'AND'.
"""
input member_role_bool_exp {
  _and: [member_role_bool_exp!]
  _not: member_role_bool_exp
  _or: [member_role_bool_exp!]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "member_role"
"""
enum member_role_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  member_role_pkey
}

enum member_role_enum {
  """Can invite members"""
  Admin

  """Can participate and edit everything"""
  Member

  """Can view but not participate"""
  Readonly
}

"""
Boolean expression to compare columns of type "member_role_enum". All fields are combined with logical 'AND'.
"""
input member_role_enum_comparison_exp {
  _eq: member_role_enum
  _in: [member_role_enum!]
  _is_null: Boolean
  _neq: member_role_enum
  _nin: [member_role_enum!]
}

"""
input type for inserting data into table "member_role"
"""
input member_role_insert_input {
  comment: String
  value: String
}

"""aggregate max on columns"""
type member_role_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type member_role_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "member_role"
"""
type member_role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [member_role!]!
}

"""
on_conflict condition type for table "member_role"
"""
input member_role_on_conflict {
  constraint: member_role_constraint!
  update_columns: [member_role_update_column!]! = []
  where: member_role_bool_exp
}

"""Ordering options when selecting data from "member_role"."""
input member_role_order_by {
  comment: order_by
  value: order_by
}

"""primary key columns input for table: member_role"""
input member_role_pk_columns_input {
  value: String!
}

"""
select columns of table "member_role"
"""
enum member_role_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "member_role"
"""
input member_role_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "member_role"
"""
input member_role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: member_role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input member_role_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "member_role"
"""
enum member_role_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input member_role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: member_role_set_input
  where: member_role_bool_exp!
}

"""
columns and relationships of "member_scope"
"""
type member_scope {
  comment: String
  value: String!
}

"""
aggregated selection of "member_scope"
"""
type member_scope_aggregate {
  aggregate: member_scope_aggregate_fields
  nodes: [member_scope!]!
}

"""
aggregate fields of "member_scope"
"""
type member_scope_aggregate_fields {
  count(columns: [member_scope_select_column!], distinct: Boolean): Int!
  max: member_scope_max_fields
  min: member_scope_min_fields
}

"""
Boolean expression to filter rows from the table "member_scope". All fields are combined with a logical 'AND'.
"""
input member_scope_bool_exp {
  _and: [member_scope_bool_exp!]
  _not: member_scope_bool_exp
  _or: [member_scope_bool_exp!]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "member_scope"
"""
enum member_scope_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  member_scope_pkey
}

enum member_scope_enum {
  """All Leaders of Roles and sub-Circles in Circle"""
  CircleLeaders

  """All members in Circle and sub-Circles"""
  CircleMembers

  """None (select members manually)"""
  None

  """All members of the organization"""
  Organization
}

"""
Boolean expression to compare columns of type "member_scope_enum". All fields are combined with logical 'AND'.
"""
input member_scope_enum_comparison_exp {
  _eq: member_scope_enum
  _in: [member_scope_enum!]
  _is_null: Boolean
  _neq: member_scope_enum
  _nin: [member_scope_enum!]
}

"""
input type for inserting data into table "member_scope"
"""
input member_scope_insert_input {
  comment: String
  value: String
}

"""aggregate max on columns"""
type member_scope_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type member_scope_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "member_scope"
"""
type member_scope_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [member_scope!]!
}

"""
on_conflict condition type for table "member_scope"
"""
input member_scope_on_conflict {
  constraint: member_scope_constraint!
  update_columns: [member_scope_update_column!]! = []
  where: member_scope_bool_exp
}

"""Ordering options when selecting data from "member_scope"."""
input member_scope_order_by {
  comment: order_by
  value: order_by
}

"""primary key columns input for table: member_scope"""
input member_scope_pk_columns_input {
  value: String!
}

"""
select columns of table "member_scope"
"""
enum member_scope_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "member_scope"
"""
input member_scope_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "member_scope"
"""
input member_scope_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: member_scope_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input member_scope_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "member_scope"
"""
enum member_scope_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input member_scope_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: member_scope_set_input
  where: member_scope_bool_exp!
}

"""
select columns of table "member"
"""
enum member_select_column {
  """column name"""
  archived

  """column name"""
  description

  """column name"""
  id

  """column name"""
  inviteDate

  """column name"""
  inviteEmail

  """column name"""
  meetingId

  """column name"""
  name

  """column name"""
  orgId

  """column name"""
  picture

  """column name"""
  pictureFileId

  """column name"""
  preferences

  """column name"""
  role

  """column name"""
  userId

  """column name"""
  workedMinPerWeek
}

"""
select "member_aggregate_bool_exp_bool_and_arguments_columns" columns of table "member"
"""
enum member_select_column_member_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived
}

"""
select "member_aggregate_bool_exp_bool_or_arguments_columns" columns of table "member"
"""
enum member_select_column_member_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived
}

"""
input type for updating data in table "member"
"""
input member_set_input {
  archived: Boolean
  description: String
  id: uuid
  inviteDate: timestamptz
  inviteEmail: String
  meetingId: uuid
  name: String
  orgId: uuid
  picture: String
  pictureFileId: uuid
  preferences: json
  role: member_role_enum
  userId: uuid
  workedMinPerWeek: Int
}

"""aggregate stddev on columns"""
type member_stddev_fields {
  workedMinPerWeek: Float
}

"""
order by stddev() on columns of table "member"
"""
input member_stddev_order_by {
  workedMinPerWeek: order_by
}

"""aggregate stddev_pop on columns"""
type member_stddev_pop_fields {
  workedMinPerWeek: Float
}

"""
order by stddev_pop() on columns of table "member"
"""
input member_stddev_pop_order_by {
  workedMinPerWeek: order_by
}

"""aggregate stddev_samp on columns"""
type member_stddev_samp_fields {
  workedMinPerWeek: Float
}

"""
order by stddev_samp() on columns of table "member"
"""
input member_stddev_samp_order_by {
  workedMinPerWeek: order_by
}

"""
Streaming cursor of the table "member"
"""
input member_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: member_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input member_stream_cursor_value_input {
  archived: Boolean
  description: String
  id: uuid
  inviteDate: timestamptz
  inviteEmail: String
  meetingId: uuid
  name: String
  orgId: uuid
  picture: String
  pictureFileId: uuid
  preferences: json
  role: member_role_enum
  userId: uuid
  workedMinPerWeek: Int
}

"""aggregate sum on columns"""
type member_sum_fields {
  workedMinPerWeek: Int
}

"""
order by sum() on columns of table "member"
"""
input member_sum_order_by {
  workedMinPerWeek: order_by
}

"""
update columns of table "member"
"""
enum member_update_column {
  """column name"""
  archived

  """column name"""
  description

  """column name"""
  id

  """column name"""
  inviteDate

  """column name"""
  inviteEmail

  """column name"""
  meetingId

  """column name"""
  name

  """column name"""
  orgId

  """column name"""
  picture

  """column name"""
  pictureFileId

  """column name"""
  preferences

  """column name"""
  role

  """column name"""
  userId

  """column name"""
  workedMinPerWeek
}

input member_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: member_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: member_set_input
  where: member_bool_exp!
}

"""aggregate var_pop on columns"""
type member_var_pop_fields {
  workedMinPerWeek: Float
}

"""
order by var_pop() on columns of table "member"
"""
input member_var_pop_order_by {
  workedMinPerWeek: order_by
}

"""aggregate var_samp on columns"""
type member_var_samp_fields {
  workedMinPerWeek: Float
}

"""
order by var_samp() on columns of table "member"
"""
input member_var_samp_order_by {
  workedMinPerWeek: order_by
}

"""aggregate variance on columns"""
type member_variance_fields {
  workedMinPerWeek: Float
}

"""
order by variance() on columns of table "member"
"""
input member_variance_order_by {
  workedMinPerWeek: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete single row from the table: "auth.providers"
  """
  deleteAuthProvider(id: String!): authProviders

  """
  delete single row from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequest(id: uuid!): authProviderRequests

  """
  delete data from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequests(
    """filter the rows which have to be deleted"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  delete data from the table: "auth.providers"
  """
  deleteAuthProviders(
    """filter the rows which have to be deleted"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(
    """
    DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
    """
    refreshToken: uuid!
  ): authRefreshTokens

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  deleteAuthRole(role: String!): authRoles

  """
  delete data from the table: "auth.roles"
  """
  deleteAuthRoles(
    """filter the rows which have to be deleted"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  delete data from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKeys(
    """filter the rows which have to be deleted"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  delete single row from the table: "storage.buckets"
  """
  deleteBucket(id: String!): buckets

  """
  delete data from the table: "storage.buckets"
  """
  deleteBuckets(
    """filter the rows which have to be deleted"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  deleteUser(id: uuid!): users

  """
  delete data from the table: "auth.users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete data from the table: "circle"
  """
  delete_circle(
    """filter the rows which have to be deleted"""
    where: circle_bool_exp!
  ): circle_mutation_response

  """
  delete single row from the table: "circle"
  """
  delete_circle_by_pk(id: uuid!): circle

  """
  delete data from the table: "circle_member"
  """
  delete_circle_member(
    """filter the rows which have to be deleted"""
    where: circle_member_bool_exp!
  ): circle_member_mutation_response

  """
  delete single row from the table: "circle_member"
  """
  delete_circle_member_by_pk(id: uuid!): circle_member

  """
  delete data from the table: "decision"
  """
  delete_decision(
    """filter the rows which have to be deleted"""
    where: decision_bool_exp!
  ): decision_mutation_response

  """
  delete single row from the table: "decision"
  """
  delete_decision_by_pk(id: uuid!): decision

  """
  delete data from the table: "log"
  """
  delete_log(
    """filter the rows which have to be deleted"""
    where: log_bool_exp!
  ): log_mutation_response

  """
  delete single row from the table: "log"
  """
  delete_log_by_pk(id: uuid!): log

  """
  delete data from the table: "meeting"
  """
  delete_meeting(
    """filter the rows which have to be deleted"""
    where: meeting_bool_exp!
  ): meeting_mutation_response

  """
  delete single row from the table: "meeting"
  """
  delete_meeting_by_pk(id: uuid!): meeting

  """
  delete data from the table: "meeting_recurring"
  """
  delete_meeting_recurring(
    """filter the rows which have to be deleted"""
    where: meeting_recurring_bool_exp!
  ): meeting_recurring_mutation_response

  """
  delete single row from the table: "meeting_recurring"
  """
  delete_meeting_recurring_by_pk(id: uuid!): meeting_recurring

  """
  delete data from the table: "meeting_step"
  """
  delete_meeting_step(
    """filter the rows which have to be deleted"""
    where: meeting_step_bool_exp!
  ): meeting_step_mutation_response

  """
  delete single row from the table: "meeting_step"
  """
  delete_meeting_step_by_pk(id: uuid!): meeting_step

  """
  delete data from the table: "meeting_step_type"
  """
  delete_meeting_step_type(
    """filter the rows which have to be deleted"""
    where: meeting_step_type_bool_exp!
  ): meeting_step_type_mutation_response

  """
  delete single row from the table: "meeting_step_type"
  """
  delete_meeting_step_type_by_pk(value: String!): meeting_step_type

  """
  delete data from the table: "meeting_template"
  """
  delete_meeting_template(
    """filter the rows which have to be deleted"""
    where: meeting_template_bool_exp!
  ): meeting_template_mutation_response

  """
  delete single row from the table: "meeting_template"
  """
  delete_meeting_template_by_pk(id: uuid!): meeting_template

  """
  delete data from the table: "member"
  """
  delete_member(
    """filter the rows which have to be deleted"""
    where: member_bool_exp!
  ): member_mutation_response

  """
  delete single row from the table: "member"
  """
  delete_member_by_pk(id: uuid!): member

  """
  delete data from the table: "member_role"
  """
  delete_member_role(
    """filter the rows which have to be deleted"""
    where: member_role_bool_exp!
  ): member_role_mutation_response

  """
  delete single row from the table: "member_role"
  """
  delete_member_role_by_pk(value: String!): member_role

  """
  delete data from the table: "member_scope"
  """
  delete_member_scope(
    """filter the rows which have to be deleted"""
    where: member_scope_bool_exp!
  ): member_scope_mutation_response

  """
  delete single row from the table: "member_scope"
  """
  delete_member_scope_by_pk(value: String!): member_scope

  """
  delete data from the table: "old_id"
  """
  delete_old_id(
    """filter the rows which have to be deleted"""
    where: old_id_bool_exp!
  ): old_id_mutation_response

  """
  delete single row from the table: "old_id"
  """
  delete_old_id_by_pk(id: uuid!): old_id

  """
  delete data from the table: "org"
  """
  delete_org(
    """filter the rows which have to be deleted"""
    where: org_bool_exp!
  ): org_mutation_response

  """
  delete single row from the table: "org"
  """
  delete_org_by_pk(id: uuid!): org

  """
  delete data from the table: "org_file"
  """
  delete_org_file(
    """filter the rows which have to be deleted"""
    where: org_file_bool_exp!
  ): org_file_mutation_response

  """
  delete single row from the table: "org_file"
  """
  delete_org_file_by_pk(id: uuid!): org_file

  """
  delete data from the table: "role"
  """
  delete_role(
    """filter the rows which have to be deleted"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  delete single row from the table: "role"
  """
  delete_role_by_pk(id: uuid!): role

  """
  delete data from the table: "task"
  """
  delete_task(
    """filter the rows which have to be deleted"""
    where: task_bool_exp!
  ): task_mutation_response

  """
  delete single row from the table: "task"
  """
  delete_task_by_pk(id: uuid!): task

  """
  delete data from the table: "task_status"
  """
  delete_task_status(
    """filter the rows which have to be deleted"""
    where: task_status_bool_exp!
  ): task_status_mutation_response

  """
  delete single row from the table: "task_status"
  """
  delete_task_status_by_pk(value: String!): task_status

  """
  delete data from the table: "task_view"
  """
  delete_task_view(
    """filter the rows which have to be deleted"""
    where: task_view_bool_exp!
  ): task_view_mutation_response

  """
  delete single row from the table: "task_view"
  """
  delete_task_view_by_pk(id: uuid!): task_view

  """
  delete data from the table: "thread"
  """
  delete_thread(
    """filter the rows which have to be deleted"""
    where: thread_bool_exp!
  ): thread_mutation_response

  """
  delete data from the table: "thread_activity"
  """
  delete_thread_activity(
    """filter the rows which have to be deleted"""
    where: thread_activity_bool_exp!
  ): thread_activity_mutation_response

  """
  delete single row from the table: "thread_activity"
  """
  delete_thread_activity_by_pk(id: uuid!): thread_activity

  """
  delete data from the table: "thread_activity_type"
  """
  delete_thread_activity_type(
    """filter the rows which have to be deleted"""
    where: thread_activity_type_bool_exp!
  ): thread_activity_type_mutation_response

  """
  delete single row from the table: "thread_activity_type"
  """
  delete_thread_activity_type_by_pk(value: String!): thread_activity_type

  """
  delete single row from the table: "thread"
  """
  delete_thread_by_pk(id: uuid!): thread

  """
  delete data from the table: "thread_member_status"
  """
  delete_thread_member_status(
    """filter the rows which have to be deleted"""
    where: thread_member_status_bool_exp!
  ): thread_member_status_mutation_response

  """
  delete single row from the table: "thread_member_status"
  """
  delete_thread_member_status_by_pk(id: uuid!): thread_member_status

  """
  delete data from the table: "thread_poll_answer"
  """
  delete_thread_poll_answer(
    """filter the rows which have to be deleted"""
    where: thread_poll_answer_bool_exp!
  ): thread_poll_answer_mutation_response

  """
  delete single row from the table: "thread_poll_answer"
  """
  delete_thread_poll_answer_by_pk(id: uuid!): thread_poll_answer

  """
  insert a single row into the table: "auth.providers"
  """
  insertAuthProvider(
    """the row to be inserted"""
    object: authProviders_insert_input!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders

  """
  insert a single row into the table: "auth.provider_requests"
  """
  insertAuthProviderRequest(
    """the row to be inserted"""
    object: authProviderRequests_insert_input!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests

  """
  insert data into the table: "auth.provider_requests"
  """
  insertAuthProviderRequests(
    """the rows to be inserted"""
    objects: [authProviderRequests_insert_input!]!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests_mutation_response

  """
  insert data into the table: "auth.providers"
  """
  insertAuthProviders(
    """the rows to be inserted"""
    objects: [authProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshToken(
    """the row to be inserted"""
    object: authRefreshTokens_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshTokens(
    """the rows to be inserted"""
    objects: [authRefreshTokens_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insertAuthRole(
    """the row to be inserted"""
    object: authRoles_insert_input!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles

  """
  insert data into the table: "auth.roles"
  """
  insertAuthRoles(
    """the rows to be inserted"""
    objects: [authRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles_mutation_response

  """
  insert a single row into the table: "auth.user_providers"
  """
  insertAuthUserProvider(
    """the row to be inserted"""
    object: authUserProviders_insert_input!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders

  """
  insert data into the table: "auth.user_providers"
  """
  insertAuthUserProviders(
    """the rows to be inserted"""
    objects: [authUserProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders_mutation_response

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKey(
    """the row to be inserted"""
    object: authUserSecurityKeys_insert_input!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys

  """
  insert data into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKeys(
    """the rows to be inserted"""
    objects: [authUserSecurityKeys_insert_input!]!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys_mutation_response

  """
  insert a single row into the table: "storage.buckets"
  """
  insertBucket(
    """the row to be inserted"""
    object: buckets_insert_input!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets

  """
  insert data into the table: "storage.buckets"
  """
  insertBuckets(
    """the rows to be inserted"""
    objects: [buckets_insert_input!]!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insertUser(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "auth.users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert data into the table: "circle"
  """
  insert_circle(
    """the rows to be inserted"""
    objects: [circle_insert_input!]!

    """upsert condition"""
    on_conflict: circle_on_conflict
  ): circle_mutation_response

  """
  insert data into the table: "circle_member"
  """
  insert_circle_member(
    """the rows to be inserted"""
    objects: [circle_member_insert_input!]!

    """upsert condition"""
    on_conflict: circle_member_on_conflict
  ): circle_member_mutation_response

  """
  insert a single row into the table: "circle_member"
  """
  insert_circle_member_one(
    """the row to be inserted"""
    object: circle_member_insert_input!

    """upsert condition"""
    on_conflict: circle_member_on_conflict
  ): circle_member

  """
  insert a single row into the table: "circle"
  """
  insert_circle_one(
    """the row to be inserted"""
    object: circle_insert_input!

    """upsert condition"""
    on_conflict: circle_on_conflict
  ): circle

  """
  insert data into the table: "decision"
  """
  insert_decision(
    """the rows to be inserted"""
    objects: [decision_insert_input!]!

    """upsert condition"""
    on_conflict: decision_on_conflict
  ): decision_mutation_response

  """
  insert a single row into the table: "decision"
  """
  insert_decision_one(
    """the row to be inserted"""
    object: decision_insert_input!

    """upsert condition"""
    on_conflict: decision_on_conflict
  ): decision

  """
  insert data into the table: "log"
  """
  insert_log(
    """the rows to be inserted"""
    objects: [log_insert_input!]!

    """upsert condition"""
    on_conflict: log_on_conflict
  ): log_mutation_response

  """
  insert a single row into the table: "log"
  """
  insert_log_one(
    """the row to be inserted"""
    object: log_insert_input!

    """upsert condition"""
    on_conflict: log_on_conflict
  ): log

  """
  insert data into the table: "meeting"
  """
  insert_meeting(
    """the rows to be inserted"""
    objects: [meeting_insert_input!]!

    """upsert condition"""
    on_conflict: meeting_on_conflict
  ): meeting_mutation_response

  """
  insert a single row into the table: "meeting"
  """
  insert_meeting_one(
    """the row to be inserted"""
    object: meeting_insert_input!

    """upsert condition"""
    on_conflict: meeting_on_conflict
  ): meeting

  """
  insert data into the table: "meeting_recurring"
  """
  insert_meeting_recurring(
    """the rows to be inserted"""
    objects: [meeting_recurring_insert_input!]!

    """upsert condition"""
    on_conflict: meeting_recurring_on_conflict
  ): meeting_recurring_mutation_response

  """
  insert a single row into the table: "meeting_recurring"
  """
  insert_meeting_recurring_one(
    """the row to be inserted"""
    object: meeting_recurring_insert_input!

    """upsert condition"""
    on_conflict: meeting_recurring_on_conflict
  ): meeting_recurring

  """
  insert data into the table: "meeting_step"
  """
  insert_meeting_step(
    """the rows to be inserted"""
    objects: [meeting_step_insert_input!]!

    """upsert condition"""
    on_conflict: meeting_step_on_conflict
  ): meeting_step_mutation_response

  """
  insert a single row into the table: "meeting_step"
  """
  insert_meeting_step_one(
    """the row to be inserted"""
    object: meeting_step_insert_input!

    """upsert condition"""
    on_conflict: meeting_step_on_conflict
  ): meeting_step

  """
  insert data into the table: "meeting_step_type"
  """
  insert_meeting_step_type(
    """the rows to be inserted"""
    objects: [meeting_step_type_insert_input!]!

    """upsert condition"""
    on_conflict: meeting_step_type_on_conflict
  ): meeting_step_type_mutation_response

  """
  insert a single row into the table: "meeting_step_type"
  """
  insert_meeting_step_type_one(
    """the row to be inserted"""
    object: meeting_step_type_insert_input!

    """upsert condition"""
    on_conflict: meeting_step_type_on_conflict
  ): meeting_step_type

  """
  insert data into the table: "meeting_template"
  """
  insert_meeting_template(
    """the rows to be inserted"""
    objects: [meeting_template_insert_input!]!

    """upsert condition"""
    on_conflict: meeting_template_on_conflict
  ): meeting_template_mutation_response

  """
  insert a single row into the table: "meeting_template"
  """
  insert_meeting_template_one(
    """the row to be inserted"""
    object: meeting_template_insert_input!

    """upsert condition"""
    on_conflict: meeting_template_on_conflict
  ): meeting_template

  """
  insert data into the table: "member"
  """
  insert_member(
    """the rows to be inserted"""
    objects: [member_insert_input!]!

    """upsert condition"""
    on_conflict: member_on_conflict
  ): member_mutation_response

  """
  insert a single row into the table: "member"
  """
  insert_member_one(
    """the row to be inserted"""
    object: member_insert_input!

    """upsert condition"""
    on_conflict: member_on_conflict
  ): member

  """
  insert data into the table: "member_role"
  """
  insert_member_role(
    """the rows to be inserted"""
    objects: [member_role_insert_input!]!

    """upsert condition"""
    on_conflict: member_role_on_conflict
  ): member_role_mutation_response

  """
  insert a single row into the table: "member_role"
  """
  insert_member_role_one(
    """the row to be inserted"""
    object: member_role_insert_input!

    """upsert condition"""
    on_conflict: member_role_on_conflict
  ): member_role

  """
  insert data into the table: "member_scope"
  """
  insert_member_scope(
    """the rows to be inserted"""
    objects: [member_scope_insert_input!]!

    """upsert condition"""
    on_conflict: member_scope_on_conflict
  ): member_scope_mutation_response

  """
  insert a single row into the table: "member_scope"
  """
  insert_member_scope_one(
    """the row to be inserted"""
    object: member_scope_insert_input!

    """upsert condition"""
    on_conflict: member_scope_on_conflict
  ): member_scope

  """
  insert data into the table: "old_id"
  """
  insert_old_id(
    """the rows to be inserted"""
    objects: [old_id_insert_input!]!

    """upsert condition"""
    on_conflict: old_id_on_conflict
  ): old_id_mutation_response

  """
  insert a single row into the table: "old_id"
  """
  insert_old_id_one(
    """the row to be inserted"""
    object: old_id_insert_input!

    """upsert condition"""
    on_conflict: old_id_on_conflict
  ): old_id

  """
  insert data into the table: "org"
  """
  insert_org(
    """the rows to be inserted"""
    objects: [org_insert_input!]!

    """upsert condition"""
    on_conflict: org_on_conflict
  ): org_mutation_response

  """
  insert data into the table: "org_file"
  """
  insert_org_file(
    """the rows to be inserted"""
    objects: [org_file_insert_input!]!

    """upsert condition"""
    on_conflict: org_file_on_conflict
  ): org_file_mutation_response

  """
  insert a single row into the table: "org_file"
  """
  insert_org_file_one(
    """the row to be inserted"""
    object: org_file_insert_input!

    """upsert condition"""
    on_conflict: org_file_on_conflict
  ): org_file

  """
  insert a single row into the table: "org"
  """
  insert_org_one(
    """the row to be inserted"""
    object: org_insert_input!

    """upsert condition"""
    on_conflict: org_on_conflict
  ): org

  """
  insert data into the table: "role"
  """
  insert_role(
    """the rows to be inserted"""
    objects: [role_insert_input!]!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role_mutation_response

  """
  insert a single row into the table: "role"
  """
  insert_role_one(
    """the row to be inserted"""
    object: role_insert_input!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role

  """
  insert data into the table: "task"
  """
  insert_task(
    """the rows to be inserted"""
    objects: [task_insert_input!]!

    """upsert condition"""
    on_conflict: task_on_conflict
  ): task_mutation_response

  """
  insert a single row into the table: "task"
  """
  insert_task_one(
    """the row to be inserted"""
    object: task_insert_input!

    """upsert condition"""
    on_conflict: task_on_conflict
  ): task

  """
  insert data into the table: "task_status"
  """
  insert_task_status(
    """the rows to be inserted"""
    objects: [task_status_insert_input!]!

    """upsert condition"""
    on_conflict: task_status_on_conflict
  ): task_status_mutation_response

  """
  insert a single row into the table: "task_status"
  """
  insert_task_status_one(
    """the row to be inserted"""
    object: task_status_insert_input!

    """upsert condition"""
    on_conflict: task_status_on_conflict
  ): task_status

  """
  insert data into the table: "task_view"
  """
  insert_task_view(
    """the rows to be inserted"""
    objects: [task_view_insert_input!]!

    """upsert condition"""
    on_conflict: task_view_on_conflict
  ): task_view_mutation_response

  """
  insert a single row into the table: "task_view"
  """
  insert_task_view_one(
    """the row to be inserted"""
    object: task_view_insert_input!

    """upsert condition"""
    on_conflict: task_view_on_conflict
  ): task_view

  """
  insert data into the table: "thread"
  """
  insert_thread(
    """the rows to be inserted"""
    objects: [thread_insert_input!]!

    """upsert condition"""
    on_conflict: thread_on_conflict
  ): thread_mutation_response

  """
  insert data into the table: "thread_activity"
  """
  insert_thread_activity(
    """the rows to be inserted"""
    objects: [thread_activity_insert_input!]!

    """upsert condition"""
    on_conflict: thread_activity_on_conflict
  ): thread_activity_mutation_response

  """
  insert a single row into the table: "thread_activity"
  """
  insert_thread_activity_one(
    """the row to be inserted"""
    object: thread_activity_insert_input!

    """upsert condition"""
    on_conflict: thread_activity_on_conflict
  ): thread_activity

  """
  insert data into the table: "thread_activity_type"
  """
  insert_thread_activity_type(
    """the rows to be inserted"""
    objects: [thread_activity_type_insert_input!]!

    """upsert condition"""
    on_conflict: thread_activity_type_on_conflict
  ): thread_activity_type_mutation_response

  """
  insert a single row into the table: "thread_activity_type"
  """
  insert_thread_activity_type_one(
    """the row to be inserted"""
    object: thread_activity_type_insert_input!

    """upsert condition"""
    on_conflict: thread_activity_type_on_conflict
  ): thread_activity_type

  """
  insert data into the table: "thread_member_status"
  """
  insert_thread_member_status(
    """the rows to be inserted"""
    objects: [thread_member_status_insert_input!]!

    """upsert condition"""
    on_conflict: thread_member_status_on_conflict
  ): thread_member_status_mutation_response

  """
  insert a single row into the table: "thread_member_status"
  """
  insert_thread_member_status_one(
    """the row to be inserted"""
    object: thread_member_status_insert_input!

    """upsert condition"""
    on_conflict: thread_member_status_on_conflict
  ): thread_member_status

  """
  insert a single row into the table: "thread"
  """
  insert_thread_one(
    """the row to be inserted"""
    object: thread_insert_input!

    """upsert condition"""
    on_conflict: thread_on_conflict
  ): thread

  """
  insert data into the table: "thread_poll_answer"
  """
  insert_thread_poll_answer(
    """the rows to be inserted"""
    objects: [thread_poll_answer_insert_input!]!

    """upsert condition"""
    on_conflict: thread_poll_answer_on_conflict
  ): thread_poll_answer_mutation_response

  """
  insert a single row into the table: "thread_poll_answer"
  """
  insert_thread_poll_answer_one(
    """the row to be inserted"""
    object: thread_poll_answer_insert_input!

    """upsert condition"""
    on_conflict: thread_poll_answer_on_conflict
  ): thread_poll_answer

  """
  update single row of the table: "auth.providers"
  """
  updateAuthProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input
    pk_columns: authProviders_pk_columns_input!
  ): authProviders

  """
  update single row of the table: "auth.provider_requests"
  """
  updateAuthProviderRequest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input
    pk_columns: authProviderRequests_pk_columns_input!
  ): authProviderRequests

  """
  update data of the table: "auth.provider_requests"
  """
  updateAuthProviderRequests(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input

    """filter the rows which have to be updated"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  update data of the table: "auth.providers"
  """
  updateAuthProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input

    """filter the rows which have to be updated"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshToken(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input
    pk_columns: authRefreshTokens_pk_columns_input!
  ): authRefreshTokens

  """
  update data of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshTokens(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  updateAuthRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input
    pk_columns: authRoles_pk_columns_input!
  ): authRoles

  """
  update data of the table: "auth.roles"
  """
  updateAuthRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input

    """filter the rows which have to be updated"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  update single row of the table: "auth.user_providers"
  """
  updateAuthUserProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input
    pk_columns: authUserProviders_pk_columns_input!
  ): authUserProviders

  """
  update data of the table: "auth.user_providers"
  """
  updateAuthUserProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input

    """filter the rows which have to be updated"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  update single row of the table: "auth.user_roles"
  """
  updateAuthUserRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input
    pk_columns: authUserRoles_pk_columns_input!
  ): authUserRoles

  """
  update data of the table: "auth.user_roles"
  """
  updateAuthUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input

    """filter the rows which have to be updated"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  update single row of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input
    pk_columns: authUserSecurityKeys_pk_columns_input!
  ): authUserSecurityKeys

  """
  update data of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKeys(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input

    """filter the rows which have to be updated"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  update single row of the table: "storage.buckets"
  """
  updateBucket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input
    pk_columns: buckets_pk_columns_input!
  ): buckets

  """
  update data of the table: "storage.buckets"
  """
  updateBuckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input

    """filter the rows which have to be updated"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  update single row of the table: "storage.files"
  """
  updateFile(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "storage.files"
  """
  updateFiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update multiples rows of table: "auth.provider_requests"
  """
  update_authProviderRequests_many(
    """updates to execute, in order"""
    updates: [authProviderRequests_updates!]!
  ): [authProviderRequests_mutation_response]

  """
  update multiples rows of table: "auth.providers"
  """
  update_authProviders_many(
    """updates to execute, in order"""
    updates: [authProviders_updates!]!
  ): [authProviders_mutation_response]

  """
  update multiples rows of table: "auth.refresh_tokens"
  """
  update_authRefreshTokens_many(
    """updates to execute, in order"""
    updates: [authRefreshTokens_updates!]!
  ): [authRefreshTokens_mutation_response]

  """
  update multiples rows of table: "auth.roles"
  """
  update_authRoles_many(
    """updates to execute, in order"""
    updates: [authRoles_updates!]!
  ): [authRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_providers"
  """
  update_authUserProviders_many(
    """updates to execute, in order"""
    updates: [authUserProviders_updates!]!
  ): [authUserProviders_mutation_response]

  """
  update multiples rows of table: "auth.user_roles"
  """
  update_authUserRoles_many(
    """updates to execute, in order"""
    updates: [authUserRoles_updates!]!
  ): [authUserRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_security_keys"
  """
  update_authUserSecurityKeys_many(
    """updates to execute, in order"""
    updates: [authUserSecurityKeys_updates!]!
  ): [authUserSecurityKeys_mutation_response]

  """
  update multiples rows of table: "storage.buckets"
  """
  update_buckets_many(
    """updates to execute, in order"""
    updates: [buckets_updates!]!
  ): [buckets_mutation_response]

  """
  update data of the table: "circle"
  """
  update_circle(
    """sets the columns of the filtered rows to the given values"""
    _set: circle_set_input

    """filter the rows which have to be updated"""
    where: circle_bool_exp!
  ): circle_mutation_response

  """
  update single row of the table: "circle"
  """
  update_circle_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: circle_set_input
    pk_columns: circle_pk_columns_input!
  ): circle

  """
  update multiples rows of table: "circle"
  """
  update_circle_many(
    """updates to execute, in order"""
    updates: [circle_updates!]!
  ): [circle_mutation_response]

  """
  update data of the table: "circle_member"
  """
  update_circle_member(
    """increments the numeric columns with given value of the filtered values"""
    _inc: circle_member_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: circle_member_set_input

    """filter the rows which have to be updated"""
    where: circle_member_bool_exp!
  ): circle_member_mutation_response

  """
  update single row of the table: "circle_member"
  """
  update_circle_member_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: circle_member_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: circle_member_set_input
    pk_columns: circle_member_pk_columns_input!
  ): circle_member

  """
  update multiples rows of table: "circle_member"
  """
  update_circle_member_many(
    """updates to execute, in order"""
    updates: [circle_member_updates!]!
  ): [circle_member_mutation_response]

  """
  update data of the table: "decision"
  """
  update_decision(
    """sets the columns of the filtered rows to the given values"""
    _set: decision_set_input

    """filter the rows which have to be updated"""
    where: decision_bool_exp!
  ): decision_mutation_response

  """
  update single row of the table: "decision"
  """
  update_decision_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: decision_set_input
    pk_columns: decision_pk_columns_input!
  ): decision

  """
  update multiples rows of table: "decision"
  """
  update_decision_many(
    """updates to execute, in order"""
    updates: [decision_updates!]!
  ): [decision_mutation_response]

  """
  update multiples rows of table: "storage.files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "log"
  """
  update_log(
    """sets the columns of the filtered rows to the given values"""
    _set: log_set_input

    """filter the rows which have to be updated"""
    where: log_bool_exp!
  ): log_mutation_response

  """
  update single row of the table: "log"
  """
  update_log_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: log_set_input
    pk_columns: log_pk_columns_input!
  ): log

  """
  update multiples rows of table: "log"
  """
  update_log_many(
    """updates to execute, in order"""
    updates: [log_updates!]!
  ): [log_mutation_response]

  """
  update data of the table: "meeting"
  """
  update_meeting(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_set_input

    """filter the rows which have to be updated"""
    where: meeting_bool_exp!
  ): meeting_mutation_response

  """
  update single row of the table: "meeting"
  """
  update_meeting_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_set_input
    pk_columns: meeting_pk_columns_input!
  ): meeting

  """
  update multiples rows of table: "meeting"
  """
  update_meeting_many(
    """updates to execute, in order"""
    updates: [meeting_updates!]!
  ): [meeting_mutation_response]

  """
  update data of the table: "meeting_recurring"
  """
  update_meeting_recurring(
    """increments the numeric columns with given value of the filtered values"""
    _inc: meeting_recurring_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: meeting_recurring_set_input

    """filter the rows which have to be updated"""
    where: meeting_recurring_bool_exp!
  ): meeting_recurring_mutation_response

  """
  update single row of the table: "meeting_recurring"
  """
  update_meeting_recurring_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: meeting_recurring_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: meeting_recurring_set_input
    pk_columns: meeting_recurring_pk_columns_input!
  ): meeting_recurring

  """
  update multiples rows of table: "meeting_recurring"
  """
  update_meeting_recurring_many(
    """updates to execute, in order"""
    updates: [meeting_recurring_updates!]!
  ): [meeting_recurring_mutation_response]

  """
  update data of the table: "meeting_step"
  """
  update_meeting_step(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_step_set_input

    """filter the rows which have to be updated"""
    where: meeting_step_bool_exp!
  ): meeting_step_mutation_response

  """
  update single row of the table: "meeting_step"
  """
  update_meeting_step_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_step_set_input
    pk_columns: meeting_step_pk_columns_input!
  ): meeting_step

  """
  update multiples rows of table: "meeting_step"
  """
  update_meeting_step_many(
    """updates to execute, in order"""
    updates: [meeting_step_updates!]!
  ): [meeting_step_mutation_response]

  """
  update data of the table: "meeting_step_type"
  """
  update_meeting_step_type(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_step_type_set_input

    """filter the rows which have to be updated"""
    where: meeting_step_type_bool_exp!
  ): meeting_step_type_mutation_response

  """
  update single row of the table: "meeting_step_type"
  """
  update_meeting_step_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_step_type_set_input
    pk_columns: meeting_step_type_pk_columns_input!
  ): meeting_step_type

  """
  update multiples rows of table: "meeting_step_type"
  """
  update_meeting_step_type_many(
    """updates to execute, in order"""
    updates: [meeting_step_type_updates!]!
  ): [meeting_step_type_mutation_response]

  """
  update data of the table: "meeting_template"
  """
  update_meeting_template(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_template_set_input

    """filter the rows which have to be updated"""
    where: meeting_template_bool_exp!
  ): meeting_template_mutation_response

  """
  update single row of the table: "meeting_template"
  """
  update_meeting_template_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: meeting_template_set_input
    pk_columns: meeting_template_pk_columns_input!
  ): meeting_template

  """
  update multiples rows of table: "meeting_template"
  """
  update_meeting_template_many(
    """updates to execute, in order"""
    updates: [meeting_template_updates!]!
  ): [meeting_template_mutation_response]

  """
  update data of the table: "member"
  """
  update_member(
    """increments the numeric columns with given value of the filtered values"""
    _inc: member_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: member_set_input

    """filter the rows which have to be updated"""
    where: member_bool_exp!
  ): member_mutation_response

  """
  update single row of the table: "member"
  """
  update_member_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: member_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: member_set_input
    pk_columns: member_pk_columns_input!
  ): member

  """
  update multiples rows of table: "member"
  """
  update_member_many(
    """updates to execute, in order"""
    updates: [member_updates!]!
  ): [member_mutation_response]

  """
  update data of the table: "member_role"
  """
  update_member_role(
    """sets the columns of the filtered rows to the given values"""
    _set: member_role_set_input

    """filter the rows which have to be updated"""
    where: member_role_bool_exp!
  ): member_role_mutation_response

  """
  update single row of the table: "member_role"
  """
  update_member_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: member_role_set_input
    pk_columns: member_role_pk_columns_input!
  ): member_role

  """
  update multiples rows of table: "member_role"
  """
  update_member_role_many(
    """updates to execute, in order"""
    updates: [member_role_updates!]!
  ): [member_role_mutation_response]

  """
  update data of the table: "member_scope"
  """
  update_member_scope(
    """sets the columns of the filtered rows to the given values"""
    _set: member_scope_set_input

    """filter the rows which have to be updated"""
    where: member_scope_bool_exp!
  ): member_scope_mutation_response

  """
  update single row of the table: "member_scope"
  """
  update_member_scope_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: member_scope_set_input
    pk_columns: member_scope_pk_columns_input!
  ): member_scope

  """
  update multiples rows of table: "member_scope"
  """
  update_member_scope_many(
    """updates to execute, in order"""
    updates: [member_scope_updates!]!
  ): [member_scope_mutation_response]

  """
  update data of the table: "old_id"
  """
  update_old_id(
    """sets the columns of the filtered rows to the given values"""
    _set: old_id_set_input

    """filter the rows which have to be updated"""
    where: old_id_bool_exp!
  ): old_id_mutation_response

  """
  update single row of the table: "old_id"
  """
  update_old_id_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: old_id_set_input
    pk_columns: old_id_pk_columns_input!
  ): old_id

  """
  update multiples rows of table: "old_id"
  """
  update_old_id_many(
    """updates to execute, in order"""
    updates: [old_id_updates!]!
  ): [old_id_mutation_response]

  """
  update data of the table: "org"
  """
  update_org(
    """increments the numeric columns with given value of the filtered values"""
    _inc: org_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: org_set_input

    """filter the rows which have to be updated"""
    where: org_bool_exp!
  ): org_mutation_response

  """
  update single row of the table: "org"
  """
  update_org_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: org_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: org_set_input
    pk_columns: org_pk_columns_input!
  ): org

  """
  update data of the table: "org_file"
  """
  update_org_file(
    """sets the columns of the filtered rows to the given values"""
    _set: org_file_set_input

    """filter the rows which have to be updated"""
    where: org_file_bool_exp!
  ): org_file_mutation_response

  """
  update single row of the table: "org_file"
  """
  update_org_file_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: org_file_set_input
    pk_columns: org_file_pk_columns_input!
  ): org_file

  """
  update multiples rows of table: "org_file"
  """
  update_org_file_many(
    """updates to execute, in order"""
    updates: [org_file_updates!]!
  ): [org_file_mutation_response]

  """
  update multiples rows of table: "org"
  """
  update_org_many(
    """updates to execute, in order"""
    updates: [org_updates!]!
  ): [org_mutation_response]

  """
  update data of the table: "role"
  """
  update_role(
    """increments the numeric columns with given value of the filtered values"""
    _inc: role_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input

    """filter the rows which have to be updated"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  update single row of the table: "role"
  """
  update_role_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: role_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input
    pk_columns: role_pk_columns_input!
  ): role

  """
  update multiples rows of table: "role"
  """
  update_role_many(
    """updates to execute, in order"""
    updates: [role_updates!]!
  ): [role_mutation_response]

  """
  update data of the table: "task"
  """
  update_task(
    """sets the columns of the filtered rows to the given values"""
    _set: task_set_input

    """filter the rows which have to be updated"""
    where: task_bool_exp!
  ): task_mutation_response

  """
  update single row of the table: "task"
  """
  update_task_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_set_input
    pk_columns: task_pk_columns_input!
  ): task

  """
  update multiples rows of table: "task"
  """
  update_task_many(
    """updates to execute, in order"""
    updates: [task_updates!]!
  ): [task_mutation_response]

  """
  update data of the table: "task_status"
  """
  update_task_status(
    """sets the columns of the filtered rows to the given values"""
    _set: task_status_set_input

    """filter the rows which have to be updated"""
    where: task_status_bool_exp!
  ): task_status_mutation_response

  """
  update single row of the table: "task_status"
  """
  update_task_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_status_set_input
    pk_columns: task_status_pk_columns_input!
  ): task_status

  """
  update multiples rows of table: "task_status"
  """
  update_task_status_many(
    """updates to execute, in order"""
    updates: [task_status_updates!]!
  ): [task_status_mutation_response]

  """
  update data of the table: "task_view"
  """
  update_task_view(
    """sets the columns of the filtered rows to the given values"""
    _set: task_view_set_input

    """filter the rows which have to be updated"""
    where: task_view_bool_exp!
  ): task_view_mutation_response

  """
  update single row of the table: "task_view"
  """
  update_task_view_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_view_set_input
    pk_columns: task_view_pk_columns_input!
  ): task_view

  """
  update multiples rows of table: "task_view"
  """
  update_task_view_many(
    """updates to execute, in order"""
    updates: [task_view_updates!]!
  ): [task_view_mutation_response]

  """
  update data of the table: "thread"
  """
  update_thread(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_set_input

    """filter the rows which have to be updated"""
    where: thread_bool_exp!
  ): thread_mutation_response

  """
  update data of the table: "thread_activity"
  """
  update_thread_activity(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_activity_set_input

    """filter the rows which have to be updated"""
    where: thread_activity_bool_exp!
  ): thread_activity_mutation_response

  """
  update single row of the table: "thread_activity"
  """
  update_thread_activity_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_activity_set_input
    pk_columns: thread_activity_pk_columns_input!
  ): thread_activity

  """
  update multiples rows of table: "thread_activity"
  """
  update_thread_activity_many(
    """updates to execute, in order"""
    updates: [thread_activity_updates!]!
  ): [thread_activity_mutation_response]

  """
  update data of the table: "thread_activity_type"
  """
  update_thread_activity_type(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_activity_type_set_input

    """filter the rows which have to be updated"""
    where: thread_activity_type_bool_exp!
  ): thread_activity_type_mutation_response

  """
  update single row of the table: "thread_activity_type"
  """
  update_thread_activity_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_activity_type_set_input
    pk_columns: thread_activity_type_pk_columns_input!
  ): thread_activity_type

  """
  update multiples rows of table: "thread_activity_type"
  """
  update_thread_activity_type_many(
    """updates to execute, in order"""
    updates: [thread_activity_type_updates!]!
  ): [thread_activity_type_mutation_response]

  """
  update single row of the table: "thread"
  """
  update_thread_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_set_input
    pk_columns: thread_pk_columns_input!
  ): thread

  """
  update multiples rows of table: "thread"
  """
  update_thread_many(
    """updates to execute, in order"""
    updates: [thread_updates!]!
  ): [thread_mutation_response]

  """
  update data of the table: "thread_member_status"
  """
  update_thread_member_status(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_member_status_set_input

    """filter the rows which have to be updated"""
    where: thread_member_status_bool_exp!
  ): thread_member_status_mutation_response

  """
  update single row of the table: "thread_member_status"
  """
  update_thread_member_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_member_status_set_input
    pk_columns: thread_member_status_pk_columns_input!
  ): thread_member_status

  """
  update multiples rows of table: "thread_member_status"
  """
  update_thread_member_status_many(
    """updates to execute, in order"""
    updates: [thread_member_status_updates!]!
  ): [thread_member_status_mutation_response]

  """
  update data of the table: "thread_poll_answer"
  """
  update_thread_poll_answer(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_poll_answer_set_input

    """filter the rows which have to be updated"""
    where: thread_poll_answer_bool_exp!
  ): thread_poll_answer_mutation_response

  """
  update single row of the table: "thread_poll_answer"
  """
  update_thread_poll_answer_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: thread_poll_answer_set_input
    pk_columns: thread_poll_answer_pk_columns_input!
  ): thread_poll_answer

  """
  update multiples rows of table: "thread_poll_answer"
  """
  update_thread_poll_answer_many(
    """updates to execute, in order"""
    updates: [thread_poll_answer_updates!]!
  ): [thread_poll_answer_mutation_response]

  """
  update multiples rows of table: "auth.users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]
}

"""
columns and relationships of "old_id"
"""
type old_id {
  id: uuid!
  oldId: String!
  type: String!
}

"""
aggregated selection of "old_id"
"""
type old_id_aggregate {
  aggregate: old_id_aggregate_fields
  nodes: [old_id!]!
}

"""
aggregate fields of "old_id"
"""
type old_id_aggregate_fields {
  count(columns: [old_id_select_column!], distinct: Boolean): Int!
  max: old_id_max_fields
  min: old_id_min_fields
}

"""
Boolean expression to filter rows from the table "old_id". All fields are combined with a logical 'AND'.
"""
input old_id_bool_exp {
  _and: [old_id_bool_exp!]
  _not: old_id_bool_exp
  _or: [old_id_bool_exp!]
  id: uuid_comparison_exp
  oldId: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "old_id"
"""
enum old_id_constraint {
  """
  unique or primary key constraint on columns "oldId"
  """
  old_id_oldId_key

  """
  unique or primary key constraint on columns "id"
  """
  old_id_pkey
}

"""
input type for inserting data into table "old_id"
"""
input old_id_insert_input {
  id: uuid
  oldId: String
  type: String
}

"""aggregate max on columns"""
type old_id_max_fields {
  id: uuid
  oldId: String
  type: String
}

"""aggregate min on columns"""
type old_id_min_fields {
  id: uuid
  oldId: String
  type: String
}

"""
response of any mutation on the table "old_id"
"""
type old_id_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [old_id!]!
}

"""
on_conflict condition type for table "old_id"
"""
input old_id_on_conflict {
  constraint: old_id_constraint!
  update_columns: [old_id_update_column!]! = []
  where: old_id_bool_exp
}

"""Ordering options when selecting data from "old_id"."""
input old_id_order_by {
  id: order_by
  oldId: order_by
  type: order_by
}

"""primary key columns input for table: old_id"""
input old_id_pk_columns_input {
  id: uuid!
}

"""
select columns of table "old_id"
"""
enum old_id_select_column {
  """column name"""
  id

  """column name"""
  oldId

  """column name"""
  type
}

"""
input type for updating data in table "old_id"
"""
input old_id_set_input {
  id: uuid
  oldId: String
  type: String
}

"""
Streaming cursor of the table "old_id"
"""
input old_id_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: old_id_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input old_id_stream_cursor_value_input {
  id: uuid
  oldId: String
  type: String
}

"""
update columns of table "old_id"
"""
enum old_id_update_column {
  """column name"""
  id

  """column name"""
  oldId

  """column name"""
  type
}

input old_id_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: old_id_set_input
  where: old_id_bool_exp!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "org"
"""
type org {
  archived: Boolean!

  """An array relationship"""
  circles(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): [circle!]!

  """An aggregate relationship"""
  circles_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): circle_aggregate!
  createdAt: timestamptz!

  """An array relationship"""
  decisions(
    """distinct select on columns"""
    distinct_on: [decision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [decision_order_by!]

    """filter the rows returned"""
    where: decision_bool_exp
  ): [decision!]!

  """An aggregate relationship"""
  decisions_aggregate(
    """distinct select on columns"""
    distinct_on: [decision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [decision_order_by!]

    """filter the rows returned"""
    where: decision_bool_exp
  ): decision_aggregate!
  defaultWorkedMinPerWeek: Int!

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): [org_file!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): org_file_aggregate!
  id: uuid!

  """An array relationship"""
  logs(
    """distinct select on columns"""
    distinct_on: [log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [log_order_by!]

    """filter the rows returned"""
    where: log_bool_exp
  ): [log!]!

  """An aggregate relationship"""
  logs_aggregate(
    """distinct select on columns"""
    distinct_on: [log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [log_order_by!]

    """filter the rows returned"""
    where: log_bool_exp
  ): log_aggregate!

  """An array relationship"""
  meeting_templates(
    """distinct select on columns"""
    distinct_on: [meeting_template_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_template_order_by!]

    """filter the rows returned"""
    where: meeting_template_bool_exp
  ): [meeting_template!]!

  """An aggregate relationship"""
  meeting_templates_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_template_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_template_order_by!]

    """filter the rows returned"""
    where: meeting_template_bool_exp
  ): meeting_template_aggregate!

  """An array relationship"""
  meetings(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): [meeting!]!

  """An aggregate relationship"""
  meetings_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): meeting_aggregate!

  """An array relationship"""
  meetings_recurring(
    """distinct select on columns"""
    distinct_on: [meeting_recurring_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_recurring_order_by!]

    """filter the rows returned"""
    where: meeting_recurring_bool_exp
  ): [meeting_recurring!]!

  """An aggregate relationship"""
  meetings_recurring_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_recurring_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_recurring_order_by!]

    """filter the rows returned"""
    where: meeting_recurring_bool_exp
  ): meeting_recurring_aggregate!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!
  name: String!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!
  slug: String

  """An array relationship"""
  task_views(
    """distinct select on columns"""
    distinct_on: [task_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_view_order_by!]

    """filter the rows returned"""
    where: task_view_bool_exp
  ): [task_view!]!

  """An aggregate relationship"""
  task_views_aggregate(
    """distinct select on columns"""
    distinct_on: [task_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_view_order_by!]

    """filter the rows returned"""
    where: task_view_bool_exp
  ): task_view_aggregate!

  """An array relationship"""
  tasks(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): [task!]!

  """An aggregate relationship"""
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): task_aggregate!

  """An array relationship"""
  threads(
    """distinct select on columns"""
    distinct_on: [thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_order_by!]

    """filter the rows returned"""
    where: thread_bool_exp
  ): [thread!]!

  """An aggregate relationship"""
  threads_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_order_by!]

    """filter the rows returned"""
    where: thread_bool_exp
  ): thread_aggregate!
}

"""
aggregated selection of "org"
"""
type org_aggregate {
  aggregate: org_aggregate_fields
  nodes: [org!]!
}

"""
aggregate fields of "org"
"""
type org_aggregate_fields {
  avg: org_avg_fields
  count(columns: [org_select_column!], distinct: Boolean): Int!
  max: org_max_fields
  min: org_min_fields
  stddev: org_stddev_fields
  stddev_pop: org_stddev_pop_fields
  stddev_samp: org_stddev_samp_fields
  sum: org_sum_fields
  var_pop: org_var_pop_fields
  var_samp: org_var_samp_fields
  variance: org_variance_fields
}

"""aggregate avg on columns"""
type org_avg_fields {
  defaultWorkedMinPerWeek: Float
}

"""
Boolean expression to filter rows from the table "org". All fields are combined with a logical 'AND'.
"""
input org_bool_exp {
  _and: [org_bool_exp!]
  _not: org_bool_exp
  _or: [org_bool_exp!]
  archived: Boolean_comparison_exp
  circles: circle_bool_exp
  circles_aggregate: circle_aggregate_bool_exp
  createdAt: timestamptz_comparison_exp
  decisions: decision_bool_exp
  decisions_aggregate: decision_aggregate_bool_exp
  defaultWorkedMinPerWeek: Int_comparison_exp
  files: org_file_bool_exp
  files_aggregate: org_file_aggregate_bool_exp
  id: uuid_comparison_exp
  logs: log_bool_exp
  logs_aggregate: log_aggregate_bool_exp
  meeting_templates: meeting_template_bool_exp
  meeting_templates_aggregate: meeting_template_aggregate_bool_exp
  meetings: meeting_bool_exp
  meetings_aggregate: meeting_aggregate_bool_exp
  meetings_recurring: meeting_recurring_bool_exp
  meetings_recurring_aggregate: meeting_recurring_aggregate_bool_exp
  members: member_bool_exp
  members_aggregate: member_aggregate_bool_exp
  name: String_comparison_exp
  roles: role_bool_exp
  roles_aggregate: role_aggregate_bool_exp
  slug: String_comparison_exp
  task_views: task_view_bool_exp
  task_views_aggregate: task_view_aggregate_bool_exp
  tasks: task_bool_exp
  tasks_aggregate: task_aggregate_bool_exp
  threads: thread_bool_exp
  threads_aggregate: thread_aggregate_bool_exp
}

"""
unique or primary key constraints on table "org"
"""
enum org_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  org_pkey

  """
  unique or primary key constraint on columns "slug"
  """
  org_slug_key
}

"""
columns and relationships of "org_file"
"""
type org_file {
  """An object relationship"""
  file: files!
  fileId: uuid!
  id: uuid!

  """An object relationship"""
  org: org!
  orgId: uuid!
}

"""
aggregated selection of "org_file"
"""
type org_file_aggregate {
  aggregate: org_file_aggregate_fields
  nodes: [org_file!]!
}

input org_file_aggregate_bool_exp {
  count: org_file_aggregate_bool_exp_count
}

input org_file_aggregate_bool_exp_count {
  arguments: [org_file_select_column!]
  distinct: Boolean
  filter: org_file_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "org_file"
"""
type org_file_aggregate_fields {
  count(columns: [org_file_select_column!], distinct: Boolean): Int!
  max: org_file_max_fields
  min: org_file_min_fields
}

"""
order by aggregate values of table "org_file"
"""
input org_file_aggregate_order_by {
  count: order_by
  max: org_file_max_order_by
  min: org_file_min_order_by
}

"""
input type for inserting array relation for remote table "org_file"
"""
input org_file_arr_rel_insert_input {
  data: [org_file_insert_input!]!

  """upsert condition"""
  on_conflict: org_file_on_conflict
}

"""
Boolean expression to filter rows from the table "org_file". All fields are combined with a logical 'AND'.
"""
input org_file_bool_exp {
  _and: [org_file_bool_exp!]
  _not: org_file_bool_exp
  _or: [org_file_bool_exp!]
  file: files_bool_exp
  fileId: uuid_comparison_exp
  id: uuid_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "org_file"
"""
enum org_file_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  org_file_pkey
}

"""
input type for inserting data into table "org_file"
"""
input org_file_insert_input {
  file: files_obj_rel_insert_input
  fileId: uuid
  id: uuid
  org: org_obj_rel_insert_input
  orgId: uuid
}

"""aggregate max on columns"""
type org_file_max_fields {
  fileId: uuid
  id: uuid
  orgId: uuid
}

"""
order by max() on columns of table "org_file"
"""
input org_file_max_order_by {
  fileId: order_by
  id: order_by
  orgId: order_by
}

"""aggregate min on columns"""
type org_file_min_fields {
  fileId: uuid
  id: uuid
  orgId: uuid
}

"""
order by min() on columns of table "org_file"
"""
input org_file_min_order_by {
  fileId: order_by
  id: order_by
  orgId: order_by
}

"""
response of any mutation on the table "org_file"
"""
type org_file_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [org_file!]!
}

"""
on_conflict condition type for table "org_file"
"""
input org_file_on_conflict {
  constraint: org_file_constraint!
  update_columns: [org_file_update_column!]! = []
  where: org_file_bool_exp
}

"""Ordering options when selecting data from "org_file"."""
input org_file_order_by {
  file: files_order_by
  fileId: order_by
  id: order_by
  org: org_order_by
  orgId: order_by
}

"""primary key columns input for table: org_file"""
input org_file_pk_columns_input {
  id: uuid!
}

"""
select columns of table "org_file"
"""
enum org_file_select_column {
  """column name"""
  fileId

  """column name"""
  id

  """column name"""
  orgId
}

"""
input type for updating data in table "org_file"
"""
input org_file_set_input {
  fileId: uuid
  id: uuid
  orgId: uuid
}

"""
Streaming cursor of the table "org_file"
"""
input org_file_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: org_file_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input org_file_stream_cursor_value_input {
  fileId: uuid
  id: uuid
  orgId: uuid
}

"""
update columns of table "org_file"
"""
enum org_file_update_column {
  """column name"""
  fileId

  """column name"""
  id

  """column name"""
  orgId
}

input org_file_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: org_file_set_input
  where: org_file_bool_exp!
}

"""
input type for incrementing numeric columns in table "org"
"""
input org_inc_input {
  defaultWorkedMinPerWeek: Int
}

"""
input type for inserting data into table "org"
"""
input org_insert_input {
  archived: Boolean
  circles: circle_arr_rel_insert_input
  createdAt: timestamptz
  decisions: decision_arr_rel_insert_input
  defaultWorkedMinPerWeek: Int
  files: org_file_arr_rel_insert_input
  id: uuid
  logs: log_arr_rel_insert_input
  meeting_templates: meeting_template_arr_rel_insert_input
  meetings: meeting_arr_rel_insert_input
  meetings_recurring: meeting_recurring_arr_rel_insert_input
  members: member_arr_rel_insert_input
  name: String
  roles: role_arr_rel_insert_input
  slug: String
  task_views: task_view_arr_rel_insert_input
  tasks: task_arr_rel_insert_input
  threads: thread_arr_rel_insert_input
}

"""aggregate max on columns"""
type org_max_fields {
  createdAt: timestamptz
  defaultWorkedMinPerWeek: Int
  id: uuid
  name: String
  slug: String
}

"""aggregate min on columns"""
type org_min_fields {
  createdAt: timestamptz
  defaultWorkedMinPerWeek: Int
  id: uuid
  name: String
  slug: String
}

"""
response of any mutation on the table "org"
"""
type org_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [org!]!
}

"""
input type for inserting object relation for remote table "org"
"""
input org_obj_rel_insert_input {
  data: org_insert_input!

  """upsert condition"""
  on_conflict: org_on_conflict
}

"""
on_conflict condition type for table "org"
"""
input org_on_conflict {
  constraint: org_constraint!
  update_columns: [org_update_column!]! = []
  where: org_bool_exp
}

"""Ordering options when selecting data from "org"."""
input org_order_by {
  archived: order_by
  circles_aggregate: circle_aggregate_order_by
  createdAt: order_by
  decisions_aggregate: decision_aggregate_order_by
  defaultWorkedMinPerWeek: order_by
  files_aggregate: org_file_aggregate_order_by
  id: order_by
  logs_aggregate: log_aggregate_order_by
  meeting_templates_aggregate: meeting_template_aggregate_order_by
  meetings_aggregate: meeting_aggregate_order_by
  meetings_recurring_aggregate: meeting_recurring_aggregate_order_by
  members_aggregate: member_aggregate_order_by
  name: order_by
  roles_aggregate: role_aggregate_order_by
  slug: order_by
  task_views_aggregate: task_view_aggregate_order_by
  tasks_aggregate: task_aggregate_order_by
  threads_aggregate: thread_aggregate_order_by
}

"""primary key columns input for table: org"""
input org_pk_columns_input {
  id: uuid!
}

"""
select columns of table "org"
"""
enum org_select_column {
  """column name"""
  archived

  """column name"""
  createdAt

  """column name"""
  defaultWorkedMinPerWeek

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug
}

"""
input type for updating data in table "org"
"""
input org_set_input {
  archived: Boolean
  createdAt: timestamptz
  defaultWorkedMinPerWeek: Int
  id: uuid
  name: String
  slug: String
}

"""aggregate stddev on columns"""
type org_stddev_fields {
  defaultWorkedMinPerWeek: Float
}

"""aggregate stddev_pop on columns"""
type org_stddev_pop_fields {
  defaultWorkedMinPerWeek: Float
}

"""aggregate stddev_samp on columns"""
type org_stddev_samp_fields {
  defaultWorkedMinPerWeek: Float
}

"""
Streaming cursor of the table "org"
"""
input org_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: org_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input org_stream_cursor_value_input {
  archived: Boolean
  createdAt: timestamptz
  defaultWorkedMinPerWeek: Int
  id: uuid
  name: String
  slug: String
}

"""aggregate sum on columns"""
type org_sum_fields {
  defaultWorkedMinPerWeek: Int
}

"""
update columns of table "org"
"""
enum org_update_column {
  """column name"""
  archived

  """column name"""
  createdAt

  """column name"""
  defaultWorkedMinPerWeek

  """column name"""
  id

  """column name"""
  name

  """column name"""
  slug
}

input org_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: org_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: org_set_input
  where: org_bool_exp!
}

"""aggregate var_pop on columns"""
type org_var_pop_fields {
  defaultWorkedMinPerWeek: Float
}

"""aggregate var_samp on columns"""
type org_var_samp_fields {
  defaultWorkedMinPerWeek: Float
}

"""aggregate variance on columns"""
type org_variance_fields {
  defaultWorkedMinPerWeek: Float
}

type query_root {
  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(
    """
    DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
    """
    refreshToken: uuid!
  ): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table: "circle"
  """
  circle(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): [circle!]!

  """
  fetch aggregated fields from the table: "circle"
  """
  circle_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): circle_aggregate!

  """fetch data from the table: "circle" using primary key columns"""
  circle_by_pk(id: uuid!): circle

  """
  fetch data from the table: "circle_member"
  """
  circle_member(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): [circle_member!]!

  """
  fetch aggregated fields from the table: "circle_member"
  """
  circle_member_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): circle_member_aggregate!

  """fetch data from the table: "circle_member" using primary key columns"""
  circle_member_by_pk(id: uuid!): circle_member

  """
  fetch data from the table: "decision"
  """
  decision(
    """distinct select on columns"""
    distinct_on: [decision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [decision_order_by!]

    """filter the rows returned"""
    where: decision_bool_exp
  ): [decision!]!

  """
  fetch aggregated fields from the table: "decision"
  """
  decision_aggregate(
    """distinct select on columns"""
    distinct_on: [decision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [decision_order_by!]

    """filter the rows returned"""
    where: decision_bool_exp
  ): decision_aggregate!

  """fetch data from the table: "decision" using primary key columns"""
  decision_by_pk(id: uuid!): decision

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table: "log"
  """
  log(
    """distinct select on columns"""
    distinct_on: [log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [log_order_by!]

    """filter the rows returned"""
    where: log_bool_exp
  ): [log!]!

  """
  fetch aggregated fields from the table: "log"
  """
  log_aggregate(
    """distinct select on columns"""
    distinct_on: [log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [log_order_by!]

    """filter the rows returned"""
    where: log_bool_exp
  ): log_aggregate!

  """fetch data from the table: "log" using primary key columns"""
  log_by_pk(id: uuid!): log

  """
  fetch data from the table: "meeting"
  """
  meeting(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): [meeting!]!

  """
  fetch aggregated fields from the table: "meeting"
  """
  meeting_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): meeting_aggregate!

  """fetch data from the table: "meeting" using primary key columns"""
  meeting_by_pk(id: uuid!): meeting

  """
  fetch data from the table: "meeting_recurring"
  """
  meeting_recurring(
    """distinct select on columns"""
    distinct_on: [meeting_recurring_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_recurring_order_by!]

    """filter the rows returned"""
    where: meeting_recurring_bool_exp
  ): [meeting_recurring!]!

  """
  fetch aggregated fields from the table: "meeting_recurring"
  """
  meeting_recurring_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_recurring_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_recurring_order_by!]

    """filter the rows returned"""
    where: meeting_recurring_bool_exp
  ): meeting_recurring_aggregate!

  """
  fetch data from the table: "meeting_recurring" using primary key columns
  """
  meeting_recurring_by_pk(id: uuid!): meeting_recurring

  """
  fetch data from the table: "meeting_stats"
  """
  meeting_stats(
    """distinct select on columns"""
    distinct_on: [meeting_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_stats_order_by!]

    """filter the rows returned"""
    where: meeting_stats_bool_exp
  ): [meeting_stats!]!

  """
  fetch aggregated fields from the table: "meeting_stats"
  """
  meeting_stats_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_stats_order_by!]

    """filter the rows returned"""
    where: meeting_stats_bool_exp
  ): meeting_stats_aggregate!

  """
  fetch data from the table: "meeting_step"
  """
  meeting_step(
    """distinct select on columns"""
    distinct_on: [meeting_step_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_order_by!]

    """filter the rows returned"""
    where: meeting_step_bool_exp
  ): [meeting_step!]!

  """
  fetch aggregated fields from the table: "meeting_step"
  """
  meeting_step_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_step_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_order_by!]

    """filter the rows returned"""
    where: meeting_step_bool_exp
  ): meeting_step_aggregate!

  """fetch data from the table: "meeting_step" using primary key columns"""
  meeting_step_by_pk(id: uuid!): meeting_step

  """
  fetch data from the table: "meeting_step_type"
  """
  meeting_step_type(
    """distinct select on columns"""
    distinct_on: [meeting_step_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_type_order_by!]

    """filter the rows returned"""
    where: meeting_step_type_bool_exp
  ): [meeting_step_type!]!

  """
  fetch aggregated fields from the table: "meeting_step_type"
  """
  meeting_step_type_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_step_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_type_order_by!]

    """filter the rows returned"""
    where: meeting_step_type_bool_exp
  ): meeting_step_type_aggregate!

  """
  fetch data from the table: "meeting_step_type" using primary key columns
  """
  meeting_step_type_by_pk(value: String!): meeting_step_type

  """
  fetch data from the table: "meeting_template"
  """
  meeting_template(
    """distinct select on columns"""
    distinct_on: [meeting_template_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_template_order_by!]

    """filter the rows returned"""
    where: meeting_template_bool_exp
  ): [meeting_template!]!

  """
  fetch aggregated fields from the table: "meeting_template"
  """
  meeting_template_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_template_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_template_order_by!]

    """filter the rows returned"""
    where: meeting_template_bool_exp
  ): meeting_template_aggregate!

  """
  fetch data from the table: "meeting_template" using primary key columns
  """
  meeting_template_by_pk(id: uuid!): meeting_template

  """
  fetch data from the table: "member"
  """
  member(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """
  fetch aggregated fields from the table: "member"
  """
  member_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!

  """fetch data from the table: "member" using primary key columns"""
  member_by_pk(id: uuid!): member

  """
  fetch data from the table: "member_role"
  """
  member_role(
    """distinct select on columns"""
    distinct_on: [member_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_role_order_by!]

    """filter the rows returned"""
    where: member_role_bool_exp
  ): [member_role!]!

  """
  fetch aggregated fields from the table: "member_role"
  """
  member_role_aggregate(
    """distinct select on columns"""
    distinct_on: [member_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_role_order_by!]

    """filter the rows returned"""
    where: member_role_bool_exp
  ): member_role_aggregate!

  """fetch data from the table: "member_role" using primary key columns"""
  member_role_by_pk(value: String!): member_role

  """
  fetch data from the table: "member_scope"
  """
  member_scope(
    """distinct select on columns"""
    distinct_on: [member_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_scope_order_by!]

    """filter the rows returned"""
    where: member_scope_bool_exp
  ): [member_scope!]!

  """
  fetch aggregated fields from the table: "member_scope"
  """
  member_scope_aggregate(
    """distinct select on columns"""
    distinct_on: [member_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_scope_order_by!]

    """filter the rows returned"""
    where: member_scope_bool_exp
  ): member_scope_aggregate!

  """fetch data from the table: "member_scope" using primary key columns"""
  member_scope_by_pk(value: String!): member_scope

  """
  fetch data from the table: "old_id"
  """
  old_id(
    """distinct select on columns"""
    distinct_on: [old_id_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [old_id_order_by!]

    """filter the rows returned"""
    where: old_id_bool_exp
  ): [old_id!]!

  """
  fetch aggregated fields from the table: "old_id"
  """
  old_id_aggregate(
    """distinct select on columns"""
    distinct_on: [old_id_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [old_id_order_by!]

    """filter the rows returned"""
    where: old_id_bool_exp
  ): old_id_aggregate!

  """fetch data from the table: "old_id" using primary key columns"""
  old_id_by_pk(id: uuid!): old_id

  """
  fetch data from the table: "org"
  """
  org(
    """distinct select on columns"""
    distinct_on: [org_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_order_by!]

    """filter the rows returned"""
    where: org_bool_exp
  ): [org!]!

  """
  fetch aggregated fields from the table: "org"
  """
  org_aggregate(
    """distinct select on columns"""
    distinct_on: [org_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_order_by!]

    """filter the rows returned"""
    where: org_bool_exp
  ): org_aggregate!

  """fetch data from the table: "org" using primary key columns"""
  org_by_pk(id: uuid!): org

  """
  fetch data from the table: "org_file"
  """
  org_file(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): [org_file!]!

  """
  fetch aggregated fields from the table: "org_file"
  """
  org_file_aggregate(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): org_file_aggregate!

  """fetch data from the table: "org_file" using primary key columns"""
  org_file_by_pk(id: uuid!): org_file

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(id: uuid!): role

  """
  fetch data from the table: "task"
  """
  task(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): [task!]!

  """
  fetch aggregated fields from the table: "task"
  """
  task_aggregate(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): task_aggregate!

  """fetch data from the table: "task" using primary key columns"""
  task_by_pk(id: uuid!): task

  """
  fetch data from the table: "task_status"
  """
  task_status(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """
  fetch aggregated fields from the table: "task_status"
  """
  task_status_aggregate(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_status_aggregate!

  """fetch data from the table: "task_status" using primary key columns"""
  task_status_by_pk(value: String!): task_status

  """
  fetch data from the table: "task_view"
  """
  task_view(
    """distinct select on columns"""
    distinct_on: [task_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_view_order_by!]

    """filter the rows returned"""
    where: task_view_bool_exp
  ): [task_view!]!

  """
  fetch aggregated fields from the table: "task_view"
  """
  task_view_aggregate(
    """distinct select on columns"""
    distinct_on: [task_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_view_order_by!]

    """filter the rows returned"""
    where: task_view_bool_exp
  ): task_view_aggregate!

  """fetch data from the table: "task_view" using primary key columns"""
  task_view_by_pk(id: uuid!): task_view

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinct_on: [thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_order_by!]

    """filter the rows returned"""
    where: thread_bool_exp
  ): [thread!]!

  """
  fetch data from the table: "thread_activity"
  """
  thread_activity(
    """distinct select on columns"""
    distinct_on: [thread_activity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_order_by!]

    """filter the rows returned"""
    where: thread_activity_bool_exp
  ): [thread_activity!]!

  """
  fetch aggregated fields from the table: "thread_activity"
  """
  thread_activity_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_activity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_order_by!]

    """filter the rows returned"""
    where: thread_activity_bool_exp
  ): thread_activity_aggregate!

  """fetch data from the table: "thread_activity" using primary key columns"""
  thread_activity_by_pk(id: uuid!): thread_activity

  """
  fetch data from the table: "thread_activity_type"
  """
  thread_activity_type(
    """distinct select on columns"""
    distinct_on: [thread_activity_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_type_order_by!]

    """filter the rows returned"""
    where: thread_activity_type_bool_exp
  ): [thread_activity_type!]!

  """
  fetch aggregated fields from the table: "thread_activity_type"
  """
  thread_activity_type_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_activity_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_type_order_by!]

    """filter the rows returned"""
    where: thread_activity_type_bool_exp
  ): thread_activity_type_aggregate!

  """
  fetch data from the table: "thread_activity_type" using primary key columns
  """
  thread_activity_type_by_pk(value: String!): thread_activity_type

  """
  fetch aggregated fields from the table: "thread"
  """
  thread_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_order_by!]

    """filter the rows returned"""
    where: thread_bool_exp
  ): thread_aggregate!

  """fetch data from the table: "thread" using primary key columns"""
  thread_by_pk(id: uuid!): thread

  """
  fetch data from the table: "thread_member_status"
  """
  thread_member_status(
    """distinct select on columns"""
    distinct_on: [thread_member_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_member_status_order_by!]

    """filter the rows returned"""
    where: thread_member_status_bool_exp
  ): [thread_member_status!]!

  """
  fetch aggregated fields from the table: "thread_member_status"
  """
  thread_member_status_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_member_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_member_status_order_by!]

    """filter the rows returned"""
    where: thread_member_status_bool_exp
  ): thread_member_status_aggregate!

  """
  fetch data from the table: "thread_member_status" using primary key columns
  """
  thread_member_status_by_pk(id: uuid!): thread_member_status

  """
  fetch data from the table: "thread_poll_answer"
  """
  thread_poll_answer(
    """distinct select on columns"""
    distinct_on: [thread_poll_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_poll_answer_order_by!]

    """filter the rows returned"""
    where: thread_poll_answer_bool_exp
  ): [thread_poll_answer!]!

  """
  fetch aggregated fields from the table: "thread_poll_answer"
  """
  thread_poll_answer_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_poll_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_poll_answer_order_by!]

    """filter the rows returned"""
    where: thread_poll_answer_bool_exp
  ): thread_poll_answer_aggregate!

  """
  fetch data from the table: "thread_poll_answer" using primary key columns
  """
  thread_poll_answer_by_pk(id: uuid!): thread_poll_answer

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
columns and relationships of "role"
"""
type role {
  accountabilities: String!
  archived: Boolean!
  autoCreate: Boolean!
  base: Boolean!
  checklist: String!

  """An array relationship"""
  circles(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): [circle!]!

  """An aggregate relationship"""
  circles_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): circle_aggregate!
  colorHue: smallint
  defaultMinPerWeek: Int
  domain: String!
  id: uuid!
  indicators: String!

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: String!
  name: String!
  notes: String!

  """An object relationship"""
  org: org!
  orgId: uuid!
  purpose: String!
  singleMember: Boolean!
}

"""
aggregated selection of "role"
"""
type role_aggregate {
  aggregate: role_aggregate_fields
  nodes: [role!]!
}

input role_aggregate_bool_exp {
  bool_and: role_aggregate_bool_exp_bool_and
  bool_or: role_aggregate_bool_exp_bool_or
  count: role_aggregate_bool_exp_count
}

input role_aggregate_bool_exp_bool_and {
  arguments: role_select_column_role_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: role_bool_exp
  predicate: Boolean_comparison_exp!
}

input role_aggregate_bool_exp_bool_or {
  arguments: role_select_column_role_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: role_bool_exp
  predicate: Boolean_comparison_exp!
}

input role_aggregate_bool_exp_count {
  arguments: [role_select_column!]
  distinct: Boolean
  filter: role_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "role"
"""
type role_aggregate_fields {
  avg: role_avg_fields
  count(columns: [role_select_column!], distinct: Boolean): Int!
  max: role_max_fields
  min: role_min_fields
  stddev: role_stddev_fields
  stddev_pop: role_stddev_pop_fields
  stddev_samp: role_stddev_samp_fields
  sum: role_sum_fields
  var_pop: role_var_pop_fields
  var_samp: role_var_samp_fields
  variance: role_variance_fields
}

"""
order by aggregate values of table "role"
"""
input role_aggregate_order_by {
  avg: role_avg_order_by
  count: order_by
  max: role_max_order_by
  min: role_min_order_by
  stddev: role_stddev_order_by
  stddev_pop: role_stddev_pop_order_by
  stddev_samp: role_stddev_samp_order_by
  sum: role_sum_order_by
  var_pop: role_var_pop_order_by
  var_samp: role_var_samp_order_by
  variance: role_variance_order_by
}

"""
input type for inserting array relation for remote table "role"
"""
input role_arr_rel_insert_input {
  data: [role_insert_input!]!

  """upsert condition"""
  on_conflict: role_on_conflict
}

"""aggregate avg on columns"""
type role_avg_fields {
  colorHue: Float
  defaultMinPerWeek: Float
}

"""
order by avg() on columns of table "role"
"""
input role_avg_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

"""
Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
"""
input role_bool_exp {
  _and: [role_bool_exp!]
  _not: role_bool_exp
  _or: [role_bool_exp!]
  accountabilities: String_comparison_exp
  archived: Boolean_comparison_exp
  autoCreate: Boolean_comparison_exp
  base: Boolean_comparison_exp
  checklist: String_comparison_exp
  circles: circle_bool_exp
  circles_aggregate: circle_aggregate_bool_exp
  colorHue: smallint_comparison_exp
  defaultMinPerWeek: Int_comparison_exp
  domain: String_comparison_exp
  id: uuid_comparison_exp
  indicators: String_comparison_exp
  link: String_comparison_exp
  name: String_comparison_exp
  notes: String_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  purpose: String_comparison_exp
  singleMember: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "role"
"""
enum role_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey
}

"""
input type for incrementing numeric columns in table "role"
"""
input role_inc_input {
  colorHue: smallint
  defaultMinPerWeek: Int
}

"""
input type for inserting data into table "role"
"""
input role_insert_input {
  accountabilities: String
  archived: Boolean
  autoCreate: Boolean
  base: Boolean
  checklist: String
  circles: circle_arr_rel_insert_input
  colorHue: smallint
  defaultMinPerWeek: Int
  domain: String
  id: uuid
  indicators: String

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: String
  name: String
  notes: String
  org: org_obj_rel_insert_input
  orgId: uuid
  purpose: String
  singleMember: Boolean
}

"""aggregate max on columns"""
type role_max_fields {
  accountabilities: String
  checklist: String
  colorHue: smallint
  defaultMinPerWeek: Int
  domain: String
  id: uuid
  indicators: String

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: String
  name: String
  notes: String
  orgId: uuid
  purpose: String
}

"""
order by max() on columns of table "role"
"""
input role_max_order_by {
  accountabilities: order_by
  checklist: order_by
  colorHue: order_by
  defaultMinPerWeek: order_by
  domain: order_by
  id: order_by
  indicators: order_by

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: order_by
  name: order_by
  notes: order_by
  orgId: order_by
  purpose: order_by
}

"""aggregate min on columns"""
type role_min_fields {
  accountabilities: String
  checklist: String
  colorHue: smallint
  defaultMinPerWeek: Int
  domain: String
  id: uuid
  indicators: String

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: String
  name: String
  notes: String
  orgId: uuid
  purpose: String
}

"""
order by min() on columns of table "role"
"""
input role_min_order_by {
  accountabilities: order_by
  checklist: order_by
  colorHue: order_by
  defaultMinPerWeek: order_by
  domain: order_by
  id: order_by
  indicators: order_by

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: order_by
  name: order_by
  notes: order_by
  orgId: order_by
  purpose: order_by
}

"""
response of any mutation on the table "role"
"""
type role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [role!]!
}

"""
input type for inserting object relation for remote table "role"
"""
input role_obj_rel_insert_input {
  data: role_insert_input!

  """upsert condition"""
  on_conflict: role_on_conflict
}

"""
on_conflict condition type for table "role"
"""
input role_on_conflict {
  constraint: role_constraint!
  update_columns: [role_update_column!]! = []
  where: role_bool_exp
}

"""Ordering options when selecting data from "role"."""
input role_order_by {
  accountabilities: order_by
  archived: order_by
  autoCreate: order_by
  base: order_by
  checklist: order_by
  circles_aggregate: circle_aggregate_order_by
  colorHue: order_by
  defaultMinPerWeek: order_by
  domain: order_by
  id: order_by
  indicators: order_by
  link: order_by
  name: order_by
  notes: order_by
  org: org_order_by
  orgId: order_by
  purpose: order_by
  singleMember: order_by
}

"""primary key columns input for table: role"""
input role_pk_columns_input {
  id: uuid!
}

"""
select columns of table "role"
"""
enum role_select_column {
  """column name"""
  accountabilities

  """column name"""
  archived

  """column name"""
  autoCreate

  """column name"""
  base

  """column name"""
  checklist

  """column name"""
  colorHue

  """column name"""
  defaultMinPerWeek

  """column name"""
  domain

  """column name"""
  id

  """column name"""
  indicators

  """column name"""
  link

  """column name"""
  name

  """column name"""
  notes

  """column name"""
  orgId

  """column name"""
  purpose

  """column name"""
  singleMember
}

"""
select "role_aggregate_bool_exp_bool_and_arguments_columns" columns of table "role"
"""
enum role_select_column_role_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived

  """column name"""
  autoCreate

  """column name"""
  base

  """column name"""
  singleMember
}

"""
select "role_aggregate_bool_exp_bool_or_arguments_columns" columns of table "role"
"""
enum role_select_column_role_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived

  """column name"""
  autoCreate

  """column name"""
  base

  """column name"""
  singleMember
}

"""
input type for updating data in table "role"
"""
input role_set_input {
  accountabilities: String
  archived: Boolean
  autoCreate: Boolean
  base: Boolean
  checklist: String
  colorHue: smallint
  defaultMinPerWeek: Int
  domain: String
  id: uuid
  indicators: String

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: String
  name: String
  notes: String
  orgId: uuid
  purpose: String
  singleMember: Boolean
}

"""aggregate stddev on columns"""
type role_stddev_fields {
  colorHue: Float
  defaultMinPerWeek: Float
}

"""
order by stddev() on columns of table "role"
"""
input role_stddev_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

"""aggregate stddev_pop on columns"""
type role_stddev_pop_fields {
  colorHue: Float
  defaultMinPerWeek: Float
}

"""
order by stddev_pop() on columns of table "role"
"""
input role_stddev_pop_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

"""aggregate stddev_samp on columns"""
type role_stddev_samp_fields {
  colorHue: Float
  defaultMinPerWeek: Float
}

"""
order by stddev_samp() on columns of table "role"
"""
input role_stddev_samp_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

"""
Streaming cursor of the table "role"
"""
input role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input role_stream_cursor_value_input {
  accountabilities: String
  archived: Boolean
  autoCreate: Boolean
  base: Boolean
  checklist: String
  colorHue: smallint
  defaultMinPerWeek: Int
  domain: String
  id: uuid
  indicators: String

  """
  Link to another circle (parent or other) to represent parent circle's purpose in this other circle.  If string, circleId.  If "Parent" = grand parent circle. If "No", not a link.
  """
  link: String
  name: String
  notes: String
  orgId: uuid
  purpose: String
  singleMember: Boolean
}

"""aggregate sum on columns"""
type role_sum_fields {
  colorHue: smallint
  defaultMinPerWeek: Int
}

"""
order by sum() on columns of table "role"
"""
input role_sum_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

"""
update columns of table "role"
"""
enum role_update_column {
  """column name"""
  accountabilities

  """column name"""
  archived

  """column name"""
  autoCreate

  """column name"""
  base

  """column name"""
  checklist

  """column name"""
  colorHue

  """column name"""
  defaultMinPerWeek

  """column name"""
  domain

  """column name"""
  id

  """column name"""
  indicators

  """column name"""
  link

  """column name"""
  name

  """column name"""
  notes

  """column name"""
  orgId

  """column name"""
  purpose

  """column name"""
  singleMember
}

input role_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: role_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: role_set_input
  where: role_bool_exp!
}

"""aggregate var_pop on columns"""
type role_var_pop_fields {
  colorHue: Float
  defaultMinPerWeek: Float
}

"""
order by var_pop() on columns of table "role"
"""
input role_var_pop_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

"""aggregate var_samp on columns"""
type role_var_samp_fields {
  colorHue: Float
  defaultMinPerWeek: Float
}

"""
order by var_samp() on columns of table "role"
"""
input role_var_samp_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

"""aggregate variance on columns"""
type role_variance_fields {
  colorHue: Float
  defaultMinPerWeek: Float
}

"""
order by variance() on columns of table "role"
"""
input role_variance_order_by {
  colorHue: order_by
  defaultMinPerWeek: order_by
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

type subscription_root {
  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.provider_requests"
  """
  authProviderRequests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviderRequests_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.providers"
  """
  authProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(
    """
    DEPRECATED: auto-generated refresh token id. Will be replaced by a genereric id column that will be used as a primary key, not the refresh token itself. Use refresh_token_hash instead.
    """
    refreshToken: uuid!
  ): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_tokens"
  """
  authRefreshTokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokens_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.roles"
  """
  authRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_providers"
  """
  authUserProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_roles"
  """
  authUserRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_security_keys"
  """
  authUserSecurityKeys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserSecurityKeys_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.buckets"
  """
  buckets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [buckets_stream_cursor_input]!

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch data from the table: "circle"
  """
  circle(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): [circle!]!

  """
  fetch aggregated fields from the table: "circle"
  """
  circle_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_order_by!]

    """filter the rows returned"""
    where: circle_bool_exp
  ): circle_aggregate!

  """fetch data from the table: "circle" using primary key columns"""
  circle_by_pk(id: uuid!): circle

  """
  fetch data from the table: "circle_member"
  """
  circle_member(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): [circle_member!]!

  """
  fetch aggregated fields from the table: "circle_member"
  """
  circle_member_aggregate(
    """distinct select on columns"""
    distinct_on: [circle_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circle_member_order_by!]

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): circle_member_aggregate!

  """fetch data from the table: "circle_member" using primary key columns"""
  circle_member_by_pk(id: uuid!): circle_member

  """
  fetch data from the table in a streaming manner: "circle_member"
  """
  circle_member_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [circle_member_stream_cursor_input]!

    """filter the rows returned"""
    where: circle_member_bool_exp
  ): [circle_member!]!

  """
  fetch data from the table in a streaming manner: "circle"
  """
  circle_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [circle_stream_cursor_input]!

    """filter the rows returned"""
    where: circle_bool_exp
  ): [circle!]!

  """
  fetch data from the table: "decision"
  """
  decision(
    """distinct select on columns"""
    distinct_on: [decision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [decision_order_by!]

    """filter the rows returned"""
    where: decision_bool_exp
  ): [decision!]!

  """
  fetch aggregated fields from the table: "decision"
  """
  decision_aggregate(
    """distinct select on columns"""
    distinct_on: [decision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [decision_order_by!]

    """filter the rows returned"""
    where: decision_bool_exp
  ): decision_aggregate!

  """fetch data from the table: "decision" using primary key columns"""
  decision_by_pk(id: uuid!): decision

  """
  fetch data from the table in a streaming manner: "decision"
  """
  decision_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [decision_stream_cursor_input]!

    """filter the rows returned"""
    where: decision_bool_exp
  ): [decision!]!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "log"
  """
  log(
    """distinct select on columns"""
    distinct_on: [log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [log_order_by!]

    """filter the rows returned"""
    where: log_bool_exp
  ): [log!]!

  """
  fetch aggregated fields from the table: "log"
  """
  log_aggregate(
    """distinct select on columns"""
    distinct_on: [log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [log_order_by!]

    """filter the rows returned"""
    where: log_bool_exp
  ): log_aggregate!

  """fetch data from the table: "log" using primary key columns"""
  log_by_pk(id: uuid!): log

  """
  fetch data from the table in a streaming manner: "log"
  """
  log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [log_stream_cursor_input]!

    """filter the rows returned"""
    where: log_bool_exp
  ): [log!]!

  """
  fetch data from the table: "meeting"
  """
  meeting(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): [meeting!]!

  """
  fetch aggregated fields from the table: "meeting"
  """
  meeting_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_order_by!]

    """filter the rows returned"""
    where: meeting_bool_exp
  ): meeting_aggregate!

  """fetch data from the table: "meeting" using primary key columns"""
  meeting_by_pk(id: uuid!): meeting

  """
  fetch data from the table: "meeting_recurring"
  """
  meeting_recurring(
    """distinct select on columns"""
    distinct_on: [meeting_recurring_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_recurring_order_by!]

    """filter the rows returned"""
    where: meeting_recurring_bool_exp
  ): [meeting_recurring!]!

  """
  fetch aggregated fields from the table: "meeting_recurring"
  """
  meeting_recurring_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_recurring_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_recurring_order_by!]

    """filter the rows returned"""
    where: meeting_recurring_bool_exp
  ): meeting_recurring_aggregate!

  """
  fetch data from the table: "meeting_recurring" using primary key columns
  """
  meeting_recurring_by_pk(id: uuid!): meeting_recurring

  """
  fetch data from the table in a streaming manner: "meeting_recurring"
  """
  meeting_recurring_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [meeting_recurring_stream_cursor_input]!

    """filter the rows returned"""
    where: meeting_recurring_bool_exp
  ): [meeting_recurring!]!

  """
  fetch data from the table: "meeting_stats"
  """
  meeting_stats(
    """distinct select on columns"""
    distinct_on: [meeting_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_stats_order_by!]

    """filter the rows returned"""
    where: meeting_stats_bool_exp
  ): [meeting_stats!]!

  """
  fetch aggregated fields from the table: "meeting_stats"
  """
  meeting_stats_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_stats_order_by!]

    """filter the rows returned"""
    where: meeting_stats_bool_exp
  ): meeting_stats_aggregate!

  """
  fetch data from the table in a streaming manner: "meeting_stats"
  """
  meeting_stats_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [meeting_stats_stream_cursor_input]!

    """filter the rows returned"""
    where: meeting_stats_bool_exp
  ): [meeting_stats!]!

  """
  fetch data from the table: "meeting_step"
  """
  meeting_step(
    """distinct select on columns"""
    distinct_on: [meeting_step_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_order_by!]

    """filter the rows returned"""
    where: meeting_step_bool_exp
  ): [meeting_step!]!

  """
  fetch aggregated fields from the table: "meeting_step"
  """
  meeting_step_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_step_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_order_by!]

    """filter the rows returned"""
    where: meeting_step_bool_exp
  ): meeting_step_aggregate!

  """fetch data from the table: "meeting_step" using primary key columns"""
  meeting_step_by_pk(id: uuid!): meeting_step

  """
  fetch data from the table in a streaming manner: "meeting_step"
  """
  meeting_step_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [meeting_step_stream_cursor_input]!

    """filter the rows returned"""
    where: meeting_step_bool_exp
  ): [meeting_step!]!

  """
  fetch data from the table: "meeting_step_type"
  """
  meeting_step_type(
    """distinct select on columns"""
    distinct_on: [meeting_step_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_type_order_by!]

    """filter the rows returned"""
    where: meeting_step_type_bool_exp
  ): [meeting_step_type!]!

  """
  fetch aggregated fields from the table: "meeting_step_type"
  """
  meeting_step_type_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_step_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_step_type_order_by!]

    """filter the rows returned"""
    where: meeting_step_type_bool_exp
  ): meeting_step_type_aggregate!

  """
  fetch data from the table: "meeting_step_type" using primary key columns
  """
  meeting_step_type_by_pk(value: String!): meeting_step_type

  """
  fetch data from the table in a streaming manner: "meeting_step_type"
  """
  meeting_step_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [meeting_step_type_stream_cursor_input]!

    """filter the rows returned"""
    where: meeting_step_type_bool_exp
  ): [meeting_step_type!]!

  """
  fetch data from the table in a streaming manner: "meeting"
  """
  meeting_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [meeting_stream_cursor_input]!

    """filter the rows returned"""
    where: meeting_bool_exp
  ): [meeting!]!

  """
  fetch data from the table: "meeting_template"
  """
  meeting_template(
    """distinct select on columns"""
    distinct_on: [meeting_template_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_template_order_by!]

    """filter the rows returned"""
    where: meeting_template_bool_exp
  ): [meeting_template!]!

  """
  fetch aggregated fields from the table: "meeting_template"
  """
  meeting_template_aggregate(
    """distinct select on columns"""
    distinct_on: [meeting_template_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [meeting_template_order_by!]

    """filter the rows returned"""
    where: meeting_template_bool_exp
  ): meeting_template_aggregate!

  """
  fetch data from the table: "meeting_template" using primary key columns
  """
  meeting_template_by_pk(id: uuid!): meeting_template

  """
  fetch data from the table in a streaming manner: "meeting_template"
  """
  meeting_template_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [meeting_template_stream_cursor_input]!

    """filter the rows returned"""
    where: meeting_template_bool_exp
  ): [meeting_template!]!

  """
  fetch data from the table: "member"
  """
  member(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """
  fetch aggregated fields from the table: "member"
  """
  member_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!

  """fetch data from the table: "member" using primary key columns"""
  member_by_pk(id: uuid!): member

  """
  fetch data from the table: "member_role"
  """
  member_role(
    """distinct select on columns"""
    distinct_on: [member_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_role_order_by!]

    """filter the rows returned"""
    where: member_role_bool_exp
  ): [member_role!]!

  """
  fetch aggregated fields from the table: "member_role"
  """
  member_role_aggregate(
    """distinct select on columns"""
    distinct_on: [member_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_role_order_by!]

    """filter the rows returned"""
    where: member_role_bool_exp
  ): member_role_aggregate!

  """fetch data from the table: "member_role" using primary key columns"""
  member_role_by_pk(value: String!): member_role

  """
  fetch data from the table in a streaming manner: "member_role"
  """
  member_role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [member_role_stream_cursor_input]!

    """filter the rows returned"""
    where: member_role_bool_exp
  ): [member_role!]!

  """
  fetch data from the table: "member_scope"
  """
  member_scope(
    """distinct select on columns"""
    distinct_on: [member_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_scope_order_by!]

    """filter the rows returned"""
    where: member_scope_bool_exp
  ): [member_scope!]!

  """
  fetch aggregated fields from the table: "member_scope"
  """
  member_scope_aggregate(
    """distinct select on columns"""
    distinct_on: [member_scope_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_scope_order_by!]

    """filter the rows returned"""
    where: member_scope_bool_exp
  ): member_scope_aggregate!

  """fetch data from the table: "member_scope" using primary key columns"""
  member_scope_by_pk(value: String!): member_scope

  """
  fetch data from the table in a streaming manner: "member_scope"
  """
  member_scope_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [member_scope_stream_cursor_input]!

    """filter the rows returned"""
    where: member_scope_bool_exp
  ): [member_scope!]!

  """
  fetch data from the table in a streaming manner: "member"
  """
  member_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [member_stream_cursor_input]!

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """
  fetch data from the table: "old_id"
  """
  old_id(
    """distinct select on columns"""
    distinct_on: [old_id_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [old_id_order_by!]

    """filter the rows returned"""
    where: old_id_bool_exp
  ): [old_id!]!

  """
  fetch aggregated fields from the table: "old_id"
  """
  old_id_aggregate(
    """distinct select on columns"""
    distinct_on: [old_id_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [old_id_order_by!]

    """filter the rows returned"""
    where: old_id_bool_exp
  ): old_id_aggregate!

  """fetch data from the table: "old_id" using primary key columns"""
  old_id_by_pk(id: uuid!): old_id

  """
  fetch data from the table in a streaming manner: "old_id"
  """
  old_id_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [old_id_stream_cursor_input]!

    """filter the rows returned"""
    where: old_id_bool_exp
  ): [old_id!]!

  """
  fetch data from the table: "org"
  """
  org(
    """distinct select on columns"""
    distinct_on: [org_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_order_by!]

    """filter the rows returned"""
    where: org_bool_exp
  ): [org!]!

  """
  fetch aggregated fields from the table: "org"
  """
  org_aggregate(
    """distinct select on columns"""
    distinct_on: [org_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_order_by!]

    """filter the rows returned"""
    where: org_bool_exp
  ): org_aggregate!

  """fetch data from the table: "org" using primary key columns"""
  org_by_pk(id: uuid!): org

  """
  fetch data from the table: "org_file"
  """
  org_file(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): [org_file!]!

  """
  fetch aggregated fields from the table: "org_file"
  """
  org_file_aggregate(
    """distinct select on columns"""
    distinct_on: [org_file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [org_file_order_by!]

    """filter the rows returned"""
    where: org_file_bool_exp
  ): org_file_aggregate!

  """fetch data from the table: "org_file" using primary key columns"""
  org_file_by_pk(id: uuid!): org_file

  """
  fetch data from the table in a streaming manner: "org_file"
  """
  org_file_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [org_file_stream_cursor_input]!

    """filter the rows returned"""
    where: org_file_bool_exp
  ): [org_file!]!

  """
  fetch data from the table in a streaming manner: "org"
  """
  org_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [org_stream_cursor_input]!

    """filter the rows returned"""
    where: org_bool_exp
  ): [org!]!

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(id: uuid!): role

  """
  fetch data from the table in a streaming manner: "role"
  """
  role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [role_stream_cursor_input]!

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch data from the table: "task"
  """
  task(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): [task!]!

  """
  fetch aggregated fields from the table: "task"
  """
  task_aggregate(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): task_aggregate!

  """fetch data from the table: "task" using primary key columns"""
  task_by_pk(id: uuid!): task

  """
  fetch data from the table: "task_status"
  """
  task_status(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """
  fetch aggregated fields from the table: "task_status"
  """
  task_status_aggregate(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_status_aggregate!

  """fetch data from the table: "task_status" using primary key columns"""
  task_status_by_pk(value: String!): task_status

  """
  fetch data from the table in a streaming manner: "task_status"
  """
  task_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [task_status_stream_cursor_input]!

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """
  fetch data from the table in a streaming manner: "task"
  """
  task_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [task_stream_cursor_input]!

    """filter the rows returned"""
    where: task_bool_exp
  ): [task!]!

  """
  fetch data from the table: "task_view"
  """
  task_view(
    """distinct select on columns"""
    distinct_on: [task_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_view_order_by!]

    """filter the rows returned"""
    where: task_view_bool_exp
  ): [task_view!]!

  """
  fetch aggregated fields from the table: "task_view"
  """
  task_view_aggregate(
    """distinct select on columns"""
    distinct_on: [task_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_view_order_by!]

    """filter the rows returned"""
    where: task_view_bool_exp
  ): task_view_aggregate!

  """fetch data from the table: "task_view" using primary key columns"""
  task_view_by_pk(id: uuid!): task_view

  """
  fetch data from the table in a streaming manner: "task_view"
  """
  task_view_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [task_view_stream_cursor_input]!

    """filter the rows returned"""
    where: task_view_bool_exp
  ): [task_view!]!

  """
  fetch data from the table: "thread"
  """
  thread(
    """distinct select on columns"""
    distinct_on: [thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_order_by!]

    """filter the rows returned"""
    where: thread_bool_exp
  ): [thread!]!

  """
  fetch data from the table: "thread_activity"
  """
  thread_activity(
    """distinct select on columns"""
    distinct_on: [thread_activity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_order_by!]

    """filter the rows returned"""
    where: thread_activity_bool_exp
  ): [thread_activity!]!

  """
  fetch aggregated fields from the table: "thread_activity"
  """
  thread_activity_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_activity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_order_by!]

    """filter the rows returned"""
    where: thread_activity_bool_exp
  ): thread_activity_aggregate!

  """fetch data from the table: "thread_activity" using primary key columns"""
  thread_activity_by_pk(id: uuid!): thread_activity

  """
  fetch data from the table in a streaming manner: "thread_activity"
  """
  thread_activity_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [thread_activity_stream_cursor_input]!

    """filter the rows returned"""
    where: thread_activity_bool_exp
  ): [thread_activity!]!

  """
  fetch data from the table: "thread_activity_type"
  """
  thread_activity_type(
    """distinct select on columns"""
    distinct_on: [thread_activity_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_type_order_by!]

    """filter the rows returned"""
    where: thread_activity_type_bool_exp
  ): [thread_activity_type!]!

  """
  fetch aggregated fields from the table: "thread_activity_type"
  """
  thread_activity_type_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_activity_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_activity_type_order_by!]

    """filter the rows returned"""
    where: thread_activity_type_bool_exp
  ): thread_activity_type_aggregate!

  """
  fetch data from the table: "thread_activity_type" using primary key columns
  """
  thread_activity_type_by_pk(value: String!): thread_activity_type

  """
  fetch data from the table in a streaming manner: "thread_activity_type"
  """
  thread_activity_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [thread_activity_type_stream_cursor_input]!

    """filter the rows returned"""
    where: thread_activity_type_bool_exp
  ): [thread_activity_type!]!

  """
  fetch aggregated fields from the table: "thread"
  """
  thread_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_order_by!]

    """filter the rows returned"""
    where: thread_bool_exp
  ): thread_aggregate!

  """fetch data from the table: "thread" using primary key columns"""
  thread_by_pk(id: uuid!): thread

  """
  fetch data from the table: "thread_member_status"
  """
  thread_member_status(
    """distinct select on columns"""
    distinct_on: [thread_member_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_member_status_order_by!]

    """filter the rows returned"""
    where: thread_member_status_bool_exp
  ): [thread_member_status!]!

  """
  fetch aggregated fields from the table: "thread_member_status"
  """
  thread_member_status_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_member_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_member_status_order_by!]

    """filter the rows returned"""
    where: thread_member_status_bool_exp
  ): thread_member_status_aggregate!

  """
  fetch data from the table: "thread_member_status" using primary key columns
  """
  thread_member_status_by_pk(id: uuid!): thread_member_status

  """
  fetch data from the table in a streaming manner: "thread_member_status"
  """
  thread_member_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [thread_member_status_stream_cursor_input]!

    """filter the rows returned"""
    where: thread_member_status_bool_exp
  ): [thread_member_status!]!

  """
  fetch data from the table: "thread_poll_answer"
  """
  thread_poll_answer(
    """distinct select on columns"""
    distinct_on: [thread_poll_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_poll_answer_order_by!]

    """filter the rows returned"""
    where: thread_poll_answer_bool_exp
  ): [thread_poll_answer!]!

  """
  fetch aggregated fields from the table: "thread_poll_answer"
  """
  thread_poll_answer_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_poll_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_poll_answer_order_by!]

    """filter the rows returned"""
    where: thread_poll_answer_bool_exp
  ): thread_poll_answer_aggregate!

  """
  fetch data from the table: "thread_poll_answer" using primary key columns
  """
  thread_poll_answer_by_pk(id: uuid!): thread_poll_answer

  """
  fetch data from the table in a streaming manner: "thread_poll_answer"
  """
  thread_poll_answer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [thread_poll_answer_stream_cursor_input]!

    """filter the rows returned"""
    where: thread_poll_answer_bool_exp
  ): [thread_poll_answer!]!

  """
  fetch data from the table in a streaming manner: "thread"
  """
  thread_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [thread_stream_cursor_input]!

    """filter the rows returned"""
    where: thread_bool_exp
  ): [thread!]!

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

"""
columns and relationships of "task"
"""
type task {
  archived: Boolean!

  """An object relationship"""
  circle: circle!
  circleId: uuid!
  createdAt: timestamptz!
  description: String!
  dueDate: timestamptz
  id: uuid!

  """An object relationship"""
  member: member
  memberId: uuid

  """An object relationship"""
  org: org!
  orgId: uuid!
  status: task_status_enum!
  title: String!
}

"""
aggregated selection of "task"
"""
type task_aggregate {
  aggregate: task_aggregate_fields
  nodes: [task!]!
}

input task_aggregate_bool_exp {
  bool_and: task_aggregate_bool_exp_bool_and
  bool_or: task_aggregate_bool_exp_bool_or
  count: task_aggregate_bool_exp_count
}

input task_aggregate_bool_exp_bool_and {
  arguments: task_select_column_task_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: task_bool_exp
  predicate: Boolean_comparison_exp!
}

input task_aggregate_bool_exp_bool_or {
  arguments: task_select_column_task_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: task_bool_exp
  predicate: Boolean_comparison_exp!
}

input task_aggregate_bool_exp_count {
  arguments: [task_select_column!]
  distinct: Boolean
  filter: task_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "task"
"""
type task_aggregate_fields {
  count(columns: [task_select_column!], distinct: Boolean): Int!
  max: task_max_fields
  min: task_min_fields
}

"""
order by aggregate values of table "task"
"""
input task_aggregate_order_by {
  count: order_by
  max: task_max_order_by
  min: task_min_order_by
}

"""
input type for inserting array relation for remote table "task"
"""
input task_arr_rel_insert_input {
  data: [task_insert_input!]!

  """upsert condition"""
  on_conflict: task_on_conflict
}

"""
Boolean expression to filter rows from the table "task". All fields are combined with a logical 'AND'.
"""
input task_bool_exp {
  _and: [task_bool_exp!]
  _not: task_bool_exp
  _or: [task_bool_exp!]
  archived: Boolean_comparison_exp
  circle: circle_bool_exp
  circleId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  dueDate: timestamptz_comparison_exp
  id: uuid_comparison_exp
  member: member_bool_exp
  memberId: uuid_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  status: task_status_enum_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "task"
"""
enum task_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  task_pkey
}

"""
input type for inserting data into table "task"
"""
input task_insert_input {
  archived: Boolean
  circle: circle_obj_rel_insert_input
  circleId: uuid
  createdAt: timestamptz
  description: String
  dueDate: timestamptz
  id: uuid
  member: member_obj_rel_insert_input
  memberId: uuid
  org: org_obj_rel_insert_input
  orgId: uuid
  status: task_status_enum
  title: String
}

"""aggregate max on columns"""
type task_max_fields {
  circleId: uuid
  createdAt: timestamptz
  description: String
  dueDate: timestamptz
  id: uuid
  memberId: uuid
  orgId: uuid
  title: String
}

"""
order by max() on columns of table "task"
"""
input task_max_order_by {
  circleId: order_by
  createdAt: order_by
  description: order_by
  dueDate: order_by
  id: order_by
  memberId: order_by
  orgId: order_by
  title: order_by
}

"""aggregate min on columns"""
type task_min_fields {
  circleId: uuid
  createdAt: timestamptz
  description: String
  dueDate: timestamptz
  id: uuid
  memberId: uuid
  orgId: uuid
  title: String
}

"""
order by min() on columns of table "task"
"""
input task_min_order_by {
  circleId: order_by
  createdAt: order_by
  description: order_by
  dueDate: order_by
  id: order_by
  memberId: order_by
  orgId: order_by
  title: order_by
}

"""
response of any mutation on the table "task"
"""
type task_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task!]!
}

"""
on_conflict condition type for table "task"
"""
input task_on_conflict {
  constraint: task_constraint!
  update_columns: [task_update_column!]! = []
  where: task_bool_exp
}

"""Ordering options when selecting data from "task"."""
input task_order_by {
  archived: order_by
  circle: circle_order_by
  circleId: order_by
  createdAt: order_by
  description: order_by
  dueDate: order_by
  id: order_by
  member: member_order_by
  memberId: order_by
  org: org_order_by
  orgId: order_by
  status: order_by
  title: order_by
}

"""primary key columns input for table: task"""
input task_pk_columns_input {
  id: uuid!
}

"""
select columns of table "task"
"""
enum task_select_column {
  """column name"""
  archived

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  dueDate

  """column name"""
  id

  """column name"""
  memberId

  """column name"""
  orgId

  """column name"""
  status

  """column name"""
  title
}

"""
select "task_aggregate_bool_exp_bool_and_arguments_columns" columns of table "task"
"""
enum task_select_column_task_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived
}

"""
select "task_aggregate_bool_exp_bool_or_arguments_columns" columns of table "task"
"""
enum task_select_column_task_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived
}

"""
input type for updating data in table "task"
"""
input task_set_input {
  archived: Boolean
  circleId: uuid
  createdAt: timestamptz
  description: String
  dueDate: timestamptz
  id: uuid
  memberId: uuid
  orgId: uuid
  status: task_status_enum
  title: String
}

"""
columns and relationships of "task_status"
"""
type task_status {
  comment: String
  value: String!
}

"""
aggregated selection of "task_status"
"""
type task_status_aggregate {
  aggregate: task_status_aggregate_fields
  nodes: [task_status!]!
}

"""
aggregate fields of "task_status"
"""
type task_status_aggregate_fields {
  count(columns: [task_status_select_column!], distinct: Boolean): Int!
  max: task_status_max_fields
  min: task_status_min_fields
}

"""
Boolean expression to filter rows from the table "task_status". All fields are combined with a logical 'AND'.
"""
input task_status_bool_exp {
  _and: [task_status_bool_exp!]
  _not: task_status_bool_exp
  _or: [task_status_bool_exp!]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "task_status"
"""
enum task_status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  task_status_pkey
}

enum task_status_enum {
  """"""
  Blocked

  """"""
  Done

  """"""
  InProgress

  """"""
  InReview

  """"""
  Open
}

"""
Boolean expression to compare columns of type "task_status_enum". All fields are combined with logical 'AND'.
"""
input task_status_enum_comparison_exp {
  _eq: task_status_enum
  _in: [task_status_enum!]
  _is_null: Boolean
  _neq: task_status_enum
  _nin: [task_status_enum!]
}

"""
input type for inserting data into table "task_status"
"""
input task_status_insert_input {
  comment: String
  value: String
}

"""aggregate max on columns"""
type task_status_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type task_status_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "task_status"
"""
type task_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task_status!]!
}

"""
on_conflict condition type for table "task_status"
"""
input task_status_on_conflict {
  constraint: task_status_constraint!
  update_columns: [task_status_update_column!]! = []
  where: task_status_bool_exp
}

"""Ordering options when selecting data from "task_status"."""
input task_status_order_by {
  comment: order_by
  value: order_by
}

"""primary key columns input for table: task_status"""
input task_status_pk_columns_input {
  value: String!
}

"""
select columns of table "task_status"
"""
enum task_status_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "task_status"
"""
input task_status_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "task_status"
"""
input task_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: task_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input task_status_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "task_status"
"""
enum task_status_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input task_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_status_set_input
  where: task_status_bool_exp!
}

"""
Streaming cursor of the table "task"
"""
input task_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: task_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input task_stream_cursor_value_input {
  archived: Boolean
  circleId: uuid
  createdAt: timestamptz
  description: String
  dueDate: timestamptz
  id: uuid
  memberId: uuid
  orgId: uuid
  status: task_status_enum
  title: String
}

"""
update columns of table "task"
"""
enum task_update_column {
  """column name"""
  archived

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  dueDate

  """column name"""
  id

  """column name"""
  memberId

  """column name"""
  orgId

  """column name"""
  status

  """column name"""
  title
}

input task_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_set_input
  where: task_bool_exp!
}

"""
columns and relationships of "task_view"
"""
type task_view {
  id: uuid!
  key: String!

  """An object relationship"""
  org: org!
  orgId: uuid!
  tasksIds(
    """JSON select path"""
    path: String
  ): json!
}

"""
aggregated selection of "task_view"
"""
type task_view_aggregate {
  aggregate: task_view_aggregate_fields
  nodes: [task_view!]!
}

input task_view_aggregate_bool_exp {
  count: task_view_aggregate_bool_exp_count
}

input task_view_aggregate_bool_exp_count {
  arguments: [task_view_select_column!]
  distinct: Boolean
  filter: task_view_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "task_view"
"""
type task_view_aggregate_fields {
  count(columns: [task_view_select_column!], distinct: Boolean): Int!
  max: task_view_max_fields
  min: task_view_min_fields
}

"""
order by aggregate values of table "task_view"
"""
input task_view_aggregate_order_by {
  count: order_by
  max: task_view_max_order_by
  min: task_view_min_order_by
}

"""
input type for inserting array relation for remote table "task_view"
"""
input task_view_arr_rel_insert_input {
  data: [task_view_insert_input!]!

  """upsert condition"""
  on_conflict: task_view_on_conflict
}

"""
Boolean expression to filter rows from the table "task_view". All fields are combined with a logical 'AND'.
"""
input task_view_bool_exp {
  _and: [task_view_bool_exp!]
  _not: task_view_bool_exp
  _or: [task_view_bool_exp!]
  id: uuid_comparison_exp
  key: String_comparison_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  tasksIds: json_comparison_exp
}

"""
unique or primary key constraints on table "task_view"
"""
enum task_view_constraint {
  """
  unique or primary key constraint on columns "key", "orgId"
  """
  task_view_orgId_key_key

  """
  unique or primary key constraint on columns "id"
  """
  task_view_pkey
}

"""
input type for inserting data into table "task_view"
"""
input task_view_insert_input {
  id: uuid
  key: String
  org: org_obj_rel_insert_input
  orgId: uuid
  tasksIds: json
}

"""aggregate max on columns"""
type task_view_max_fields {
  id: uuid
  key: String
  orgId: uuid
}

"""
order by max() on columns of table "task_view"
"""
input task_view_max_order_by {
  id: order_by
  key: order_by
  orgId: order_by
}

"""aggregate min on columns"""
type task_view_min_fields {
  id: uuid
  key: String
  orgId: uuid
}

"""
order by min() on columns of table "task_view"
"""
input task_view_min_order_by {
  id: order_by
  key: order_by
  orgId: order_by
}

"""
response of any mutation on the table "task_view"
"""
type task_view_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task_view!]!
}

"""
on_conflict condition type for table "task_view"
"""
input task_view_on_conflict {
  constraint: task_view_constraint!
  update_columns: [task_view_update_column!]! = []
  where: task_view_bool_exp
}

"""Ordering options when selecting data from "task_view"."""
input task_view_order_by {
  id: order_by
  key: order_by
  org: org_order_by
  orgId: order_by
  tasksIds: order_by
}

"""primary key columns input for table: task_view"""
input task_view_pk_columns_input {
  id: uuid!
}

"""
select columns of table "task_view"
"""
enum task_view_select_column {
  """column name"""
  id

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  tasksIds
}

"""
input type for updating data in table "task_view"
"""
input task_view_set_input {
  id: uuid
  key: String
  orgId: uuid
  tasksIds: json
}

"""
Streaming cursor of the table "task_view"
"""
input task_view_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: task_view_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input task_view_stream_cursor_value_input {
  id: uuid
  key: String
  orgId: uuid
  tasksIds: json
}

"""
update columns of table "task_view"
"""
enum task_view_update_column {
  """column name"""
  id

  """column name"""
  key

  """column name"""
  orgId

  """column name"""
  tasksIds
}

input task_view_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_view_set_input
  where: task_view_bool_exp!
}

"""
columns and relationships of "thread"
"""
type thread {
  archived: Boolean!

  """An object relationship"""
  circle: circle!
  circleId: uuid!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  initiatorMember: member!
  initiatorMemberId: uuid!
  lastActivityDate: timestamptz
  lastActivityId: uuid

  """An array relationship"""
  member_status(
    """distinct select on columns"""
    distinct_on: [thread_member_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_member_status_order_by!]

    """filter the rows returned"""
    where: thread_member_status_bool_exp
  ): [thread_member_status!]!

  """An aggregate relationship"""
  member_status_aggregate(
    """distinct select on columns"""
    distinct_on: [thread_member_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thread_member_status_order_by!]

    """filter the rows returned"""
    where: thread_member_status_bool_exp
  ): thread_member_status_aggregate!

  """An object relationship"""
  org: org!
  orgId: uuid!
  participantsMembersIds(
    """JSON select path"""
    path: String
  ): json!
  participantsScope: member_scope_enum!
  title: String!
}

"""
columns and relationships of "thread_activity"
"""
type thread_activity {
  createdAt: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): json!
  id: uuid!

  """An object relationship"""
  thread: thread!
  threadId: uuid!
  type: thread_activity_type_enum!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "thread_activity"
"""
type thread_activity_aggregate {
  aggregate: thread_activity_aggregate_fields
  nodes: [thread_activity!]!
}

"""
aggregate fields of "thread_activity"
"""
type thread_activity_aggregate_fields {
  count(columns: [thread_activity_select_column!], distinct: Boolean): Int!
  max: thread_activity_max_fields
  min: thread_activity_min_fields
}

"""
Boolean expression to filter rows from the table "thread_activity". All fields are combined with a logical 'AND'.
"""
input thread_activity_bool_exp {
  _and: [thread_activity_bool_exp!]
  _not: thread_activity_bool_exp
  _or: [thread_activity_bool_exp!]
  createdAt: timestamptz_comparison_exp
  data: json_comparison_exp
  id: uuid_comparison_exp
  thread: thread_bool_exp
  threadId: uuid_comparison_exp
  type: thread_activity_type_enum_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "thread_activity"
"""
enum thread_activity_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  thread_activity_pkey
}

"""
input type for inserting data into table "thread_activity"
"""
input thread_activity_insert_input {
  createdAt: timestamptz
  data: json
  id: uuid
  thread: thread_obj_rel_insert_input
  threadId: uuid
  type: thread_activity_type_enum
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type thread_activity_max_fields {
  createdAt: timestamptz
  id: uuid
  threadId: uuid
  userId: uuid
}

"""aggregate min on columns"""
type thread_activity_min_fields {
  createdAt: timestamptz
  id: uuid
  threadId: uuid
  userId: uuid
}

"""
response of any mutation on the table "thread_activity"
"""
type thread_activity_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [thread_activity!]!
}

"""
input type for inserting object relation for remote table "thread_activity"
"""
input thread_activity_obj_rel_insert_input {
  data: thread_activity_insert_input!

  """upsert condition"""
  on_conflict: thread_activity_on_conflict
}

"""
on_conflict condition type for table "thread_activity"
"""
input thread_activity_on_conflict {
  constraint: thread_activity_constraint!
  update_columns: [thread_activity_update_column!]! = []
  where: thread_activity_bool_exp
}

"""Ordering options when selecting data from "thread_activity"."""
input thread_activity_order_by {
  createdAt: order_by
  data: order_by
  id: order_by
  thread: thread_order_by
  threadId: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: thread_activity"""
input thread_activity_pk_columns_input {
  id: uuid!
}

"""
select columns of table "thread_activity"
"""
enum thread_activity_select_column {
  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  id

  """column name"""
  threadId

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "thread_activity"
"""
input thread_activity_set_input {
  createdAt: timestamptz
  data: json
  id: uuid
  threadId: uuid
  type: thread_activity_type_enum
  userId: uuid
}

"""
Streaming cursor of the table "thread_activity"
"""
input thread_activity_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: thread_activity_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input thread_activity_stream_cursor_value_input {
  createdAt: timestamptz
  data: json
  id: uuid
  threadId: uuid
  type: thread_activity_type_enum
  userId: uuid
}

"""
columns and relationships of "thread_activity_type"
"""
type thread_activity_type {
  comment: String
  value: String!
}

"""
aggregated selection of "thread_activity_type"
"""
type thread_activity_type_aggregate {
  aggregate: thread_activity_type_aggregate_fields
  nodes: [thread_activity_type!]!
}

"""
aggregate fields of "thread_activity_type"
"""
type thread_activity_type_aggregate_fields {
  count(columns: [thread_activity_type_select_column!], distinct: Boolean): Int!
  max: thread_activity_type_max_fields
  min: thread_activity_type_min_fields
}

"""
Boolean expression to filter rows from the table "thread_activity_type". All fields are combined with a logical 'AND'.
"""
input thread_activity_type_bool_exp {
  _and: [thread_activity_type_bool_exp!]
  _not: thread_activity_type_bool_exp
  _or: [thread_activity_type_bool_exp!]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "thread_activity_type"
"""
enum thread_activity_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  thread_activity_type_pkey
}

enum thread_activity_type_enum {
  """"""
  Decision

  """"""
  Meeting

  """"""
  Message

  """"""
  Poll

  """"""
  Task

  """"""
  Thread
}

"""
Boolean expression to compare columns of type "thread_activity_type_enum". All fields are combined with logical 'AND'.
"""
input thread_activity_type_enum_comparison_exp {
  _eq: thread_activity_type_enum
  _in: [thread_activity_type_enum!]
  _is_null: Boolean
  _neq: thread_activity_type_enum
  _nin: [thread_activity_type_enum!]
}

"""
input type for inserting data into table "thread_activity_type"
"""
input thread_activity_type_insert_input {
  comment: String
  value: String
}

"""aggregate max on columns"""
type thread_activity_type_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type thread_activity_type_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "thread_activity_type"
"""
type thread_activity_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [thread_activity_type!]!
}

"""
on_conflict condition type for table "thread_activity_type"
"""
input thread_activity_type_on_conflict {
  constraint: thread_activity_type_constraint!
  update_columns: [thread_activity_type_update_column!]! = []
  where: thread_activity_type_bool_exp
}

"""Ordering options when selecting data from "thread_activity_type"."""
input thread_activity_type_order_by {
  comment: order_by
  value: order_by
}

"""primary key columns input for table: thread_activity_type"""
input thread_activity_type_pk_columns_input {
  value: String!
}

"""
select columns of table "thread_activity_type"
"""
enum thread_activity_type_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "thread_activity_type"
"""
input thread_activity_type_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "thread_activity_type"
"""
input thread_activity_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: thread_activity_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input thread_activity_type_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "thread_activity_type"
"""
enum thread_activity_type_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input thread_activity_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: thread_activity_type_set_input
  where: thread_activity_type_bool_exp!
}

"""
update columns of table "thread_activity"
"""
enum thread_activity_update_column {
  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  id

  """column name"""
  threadId

  """column name"""
  type

  """column name"""
  userId
}

input thread_activity_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: thread_activity_set_input
  where: thread_activity_bool_exp!
}

"""
aggregated selection of "thread"
"""
type thread_aggregate {
  aggregate: thread_aggregate_fields
  nodes: [thread!]!
}

input thread_aggregate_bool_exp {
  bool_and: thread_aggregate_bool_exp_bool_and
  bool_or: thread_aggregate_bool_exp_bool_or
  count: thread_aggregate_bool_exp_count
}

input thread_aggregate_bool_exp_bool_and {
  arguments: thread_select_column_thread_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: thread_bool_exp
  predicate: Boolean_comparison_exp!
}

input thread_aggregate_bool_exp_bool_or {
  arguments: thread_select_column_thread_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: thread_bool_exp
  predicate: Boolean_comparison_exp!
}

input thread_aggregate_bool_exp_count {
  arguments: [thread_select_column!]
  distinct: Boolean
  filter: thread_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "thread"
"""
type thread_aggregate_fields {
  count(columns: [thread_select_column!], distinct: Boolean): Int!
  max: thread_max_fields
  min: thread_min_fields
}

"""
order by aggregate values of table "thread"
"""
input thread_aggregate_order_by {
  count: order_by
  max: thread_max_order_by
  min: thread_min_order_by
}

"""
input type for inserting array relation for remote table "thread"
"""
input thread_arr_rel_insert_input {
  data: [thread_insert_input!]!

  """upsert condition"""
  on_conflict: thread_on_conflict
}

"""
Boolean expression to filter rows from the table "thread". All fields are combined with a logical 'AND'.
"""
input thread_bool_exp {
  _and: [thread_bool_exp!]
  _not: thread_bool_exp
  _or: [thread_bool_exp!]
  archived: Boolean_comparison_exp
  circle: circle_bool_exp
  circleId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  initiatorMember: member_bool_exp
  initiatorMemberId: uuid_comparison_exp
  lastActivityDate: timestamptz_comparison_exp
  lastActivityId: uuid_comparison_exp
  member_status: thread_member_status_bool_exp
  member_status_aggregate: thread_member_status_aggregate_bool_exp
  org: org_bool_exp
  orgId: uuid_comparison_exp
  participantsMembersIds: json_comparison_exp
  participantsScope: member_scope_enum_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "thread"
"""
enum thread_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  thread_pkey
}

"""
input type for inserting data into table "thread"
"""
input thread_insert_input {
  archived: Boolean
  circle: circle_obj_rel_insert_input
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  initiatorMember: member_obj_rel_insert_input
  initiatorMemberId: uuid
  lastActivityDate: timestamptz
  lastActivityId: uuid
  member_status: thread_member_status_arr_rel_insert_input
  org: org_obj_rel_insert_input
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  title: String
}

"""aggregate max on columns"""
type thread_max_fields {
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  initiatorMemberId: uuid
  lastActivityDate: timestamptz
  lastActivityId: uuid
  orgId: uuid
  title: String
}

"""
order by max() on columns of table "thread"
"""
input thread_max_order_by {
  circleId: order_by
  createdAt: order_by
  id: order_by
  initiatorMemberId: order_by
  lastActivityDate: order_by
  lastActivityId: order_by
  orgId: order_by
  title: order_by
}

"""
columns and relationships of "thread_member_status"
"""
type thread_member_status {
  id: uuid!
  lastReadActivityId: uuid
  lastReadDate: timestamptz!

  """An object relationship"""
  member: member!
  memberId: uuid!

  """An object relationship"""
  thread: thread!
  threadId: uuid!
}

"""
aggregated selection of "thread_member_status"
"""
type thread_member_status_aggregate {
  aggregate: thread_member_status_aggregate_fields
  nodes: [thread_member_status!]!
}

input thread_member_status_aggregate_bool_exp {
  count: thread_member_status_aggregate_bool_exp_count
}

input thread_member_status_aggregate_bool_exp_count {
  arguments: [thread_member_status_select_column!]
  distinct: Boolean
  filter: thread_member_status_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "thread_member_status"
"""
type thread_member_status_aggregate_fields {
  count(columns: [thread_member_status_select_column!], distinct: Boolean): Int!
  max: thread_member_status_max_fields
  min: thread_member_status_min_fields
}

"""
order by aggregate values of table "thread_member_status"
"""
input thread_member_status_aggregate_order_by {
  count: order_by
  max: thread_member_status_max_order_by
  min: thread_member_status_min_order_by
}

"""
input type for inserting array relation for remote table "thread_member_status"
"""
input thread_member_status_arr_rel_insert_input {
  data: [thread_member_status_insert_input!]!

  """upsert condition"""
  on_conflict: thread_member_status_on_conflict
}

"""
Boolean expression to filter rows from the table "thread_member_status". All fields are combined with a logical 'AND'.
"""
input thread_member_status_bool_exp {
  _and: [thread_member_status_bool_exp!]
  _not: thread_member_status_bool_exp
  _or: [thread_member_status_bool_exp!]
  id: uuid_comparison_exp
  lastReadActivityId: uuid_comparison_exp
  lastReadDate: timestamptz_comparison_exp
  member: member_bool_exp
  memberId: uuid_comparison_exp
  thread: thread_bool_exp
  threadId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "thread_member_status"
"""
enum thread_member_status_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  thread_member_status_pkey

  """
  unique or primary key constraint on columns "memberId", "threadId"
  """
  thread_member_status_threadId_memberId_key
}

"""
input type for inserting data into table "thread_member_status"
"""
input thread_member_status_insert_input {
  id: uuid
  lastReadActivityId: uuid
  lastReadDate: timestamptz
  member: member_obj_rel_insert_input
  memberId: uuid
  thread: thread_obj_rel_insert_input
  threadId: uuid
}

"""aggregate max on columns"""
type thread_member_status_max_fields {
  id: uuid
  lastReadActivityId: uuid
  lastReadDate: timestamptz
  memberId: uuid
  threadId: uuid
}

"""
order by max() on columns of table "thread_member_status"
"""
input thread_member_status_max_order_by {
  id: order_by
  lastReadActivityId: order_by
  lastReadDate: order_by
  memberId: order_by
  threadId: order_by
}

"""aggregate min on columns"""
type thread_member_status_min_fields {
  id: uuid
  lastReadActivityId: uuid
  lastReadDate: timestamptz
  memberId: uuid
  threadId: uuid
}

"""
order by min() on columns of table "thread_member_status"
"""
input thread_member_status_min_order_by {
  id: order_by
  lastReadActivityId: order_by
  lastReadDate: order_by
  memberId: order_by
  threadId: order_by
}

"""
response of any mutation on the table "thread_member_status"
"""
type thread_member_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [thread_member_status!]!
}

"""
on_conflict condition type for table "thread_member_status"
"""
input thread_member_status_on_conflict {
  constraint: thread_member_status_constraint!
  update_columns: [thread_member_status_update_column!]! = []
  where: thread_member_status_bool_exp
}

"""Ordering options when selecting data from "thread_member_status"."""
input thread_member_status_order_by {
  id: order_by
  lastReadActivityId: order_by
  lastReadDate: order_by
  member: member_order_by
  memberId: order_by
  thread: thread_order_by
  threadId: order_by
}

"""primary key columns input for table: thread_member_status"""
input thread_member_status_pk_columns_input {
  id: uuid!
}

"""
select columns of table "thread_member_status"
"""
enum thread_member_status_select_column {
  """column name"""
  id

  """column name"""
  lastReadActivityId

  """column name"""
  lastReadDate

  """column name"""
  memberId

  """column name"""
  threadId
}

"""
input type for updating data in table "thread_member_status"
"""
input thread_member_status_set_input {
  id: uuid
  lastReadActivityId: uuid
  lastReadDate: timestamptz
  memberId: uuid
  threadId: uuid
}

"""
Streaming cursor of the table "thread_member_status"
"""
input thread_member_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: thread_member_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input thread_member_status_stream_cursor_value_input {
  id: uuid
  lastReadActivityId: uuid
  lastReadDate: timestamptz
  memberId: uuid
  threadId: uuid
}

"""
update columns of table "thread_member_status"
"""
enum thread_member_status_update_column {
  """column name"""
  id

  """column name"""
  lastReadActivityId

  """column name"""
  lastReadDate

  """column name"""
  memberId

  """column name"""
  threadId
}

input thread_member_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: thread_member_status_set_input
  where: thread_member_status_bool_exp!
}

"""aggregate min on columns"""
type thread_min_fields {
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  initiatorMemberId: uuid
  lastActivityDate: timestamptz
  lastActivityId: uuid
  orgId: uuid
  title: String
}

"""
order by min() on columns of table "thread"
"""
input thread_min_order_by {
  circleId: order_by
  createdAt: order_by
  id: order_by
  initiatorMemberId: order_by
  lastActivityDate: order_by
  lastActivityId: order_by
  orgId: order_by
  title: order_by
}

"""
response of any mutation on the table "thread"
"""
type thread_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [thread!]!
}

"""
input type for inserting object relation for remote table "thread"
"""
input thread_obj_rel_insert_input {
  data: thread_insert_input!

  """upsert condition"""
  on_conflict: thread_on_conflict
}

"""
on_conflict condition type for table "thread"
"""
input thread_on_conflict {
  constraint: thread_constraint!
  update_columns: [thread_update_column!]! = []
  where: thread_bool_exp
}

"""Ordering options when selecting data from "thread"."""
input thread_order_by {
  archived: order_by
  circle: circle_order_by
  circleId: order_by
  createdAt: order_by
  id: order_by
  initiatorMember: member_order_by
  initiatorMemberId: order_by
  lastActivityDate: order_by
  lastActivityId: order_by
  member_status_aggregate: thread_member_status_aggregate_order_by
  org: org_order_by
  orgId: order_by
  participantsMembersIds: order_by
  participantsScope: order_by
  title: order_by
}

"""primary key columns input for table: thread"""
input thread_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "thread_poll_answer"
"""
type thread_poll_answer {
  """An object relationship"""
  activity: thread_activity!
  activityId: uuid!
  choicesPoints(
    """JSON select path"""
    path: String
  ): json!
  createdAt: timestamptz!
  id: uuid!
  userId: uuid!
}

"""
aggregated selection of "thread_poll_answer"
"""
type thread_poll_answer_aggregate {
  aggregate: thread_poll_answer_aggregate_fields
  nodes: [thread_poll_answer!]!
}

"""
aggregate fields of "thread_poll_answer"
"""
type thread_poll_answer_aggregate_fields {
  count(columns: [thread_poll_answer_select_column!], distinct: Boolean): Int!
  max: thread_poll_answer_max_fields
  min: thread_poll_answer_min_fields
}

"""
Boolean expression to filter rows from the table "thread_poll_answer". All fields are combined with a logical 'AND'.
"""
input thread_poll_answer_bool_exp {
  _and: [thread_poll_answer_bool_exp!]
  _not: thread_poll_answer_bool_exp
  _or: [thread_poll_answer_bool_exp!]
  activity: thread_activity_bool_exp
  activityId: uuid_comparison_exp
  choicesPoints: json_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "thread_poll_answer"
"""
enum thread_poll_answer_constraint {
  """
  unique or primary key constraint on columns "userId", "activityId"
  """
  thread_poll_answer_activityId_userId_key

  """
  unique or primary key constraint on columns "id"
  """
  thread_poll_answer_pkey
}

"""
input type for inserting data into table "thread_poll_answer"
"""
input thread_poll_answer_insert_input {
  activity: thread_activity_obj_rel_insert_input
  activityId: uuid
  choicesPoints: json
  createdAt: timestamptz
  id: uuid
  userId: uuid
}

"""aggregate max on columns"""
type thread_poll_answer_max_fields {
  activityId: uuid
  createdAt: timestamptz
  id: uuid
  userId: uuid
}

"""aggregate min on columns"""
type thread_poll_answer_min_fields {
  activityId: uuid
  createdAt: timestamptz
  id: uuid
  userId: uuid
}

"""
response of any mutation on the table "thread_poll_answer"
"""
type thread_poll_answer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [thread_poll_answer!]!
}

"""
on_conflict condition type for table "thread_poll_answer"
"""
input thread_poll_answer_on_conflict {
  constraint: thread_poll_answer_constraint!
  update_columns: [thread_poll_answer_update_column!]! = []
  where: thread_poll_answer_bool_exp
}

"""Ordering options when selecting data from "thread_poll_answer"."""
input thread_poll_answer_order_by {
  activity: thread_activity_order_by
  activityId: order_by
  choicesPoints: order_by
  createdAt: order_by
  id: order_by
  userId: order_by
}

"""primary key columns input for table: thread_poll_answer"""
input thread_poll_answer_pk_columns_input {
  id: uuid!
}

"""
select columns of table "thread_poll_answer"
"""
enum thread_poll_answer_select_column {
  """column name"""
  activityId

  """column name"""
  choicesPoints

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  userId
}

"""
input type for updating data in table "thread_poll_answer"
"""
input thread_poll_answer_set_input {
  activityId: uuid
  choicesPoints: json
  createdAt: timestamptz
  id: uuid
  userId: uuid
}

"""
Streaming cursor of the table "thread_poll_answer"
"""
input thread_poll_answer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: thread_poll_answer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input thread_poll_answer_stream_cursor_value_input {
  activityId: uuid
  choicesPoints: json
  createdAt: timestamptz
  id: uuid
  userId: uuid
}

"""
update columns of table "thread_poll_answer"
"""
enum thread_poll_answer_update_column {
  """column name"""
  activityId

  """column name"""
  choicesPoints

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  userId
}

input thread_poll_answer_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: thread_poll_answer_set_input
  where: thread_poll_answer_bool_exp!
}

"""
select columns of table "thread"
"""
enum thread_select_column {
  """column name"""
  archived

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  initiatorMemberId

  """column name"""
  lastActivityDate

  """column name"""
  lastActivityId

  """column name"""
  orgId

  """column name"""
  participantsMembersIds

  """column name"""
  participantsScope

  """column name"""
  title
}

"""
select "thread_aggregate_bool_exp_bool_and_arguments_columns" columns of table "thread"
"""
enum thread_select_column_thread_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived
}

"""
select "thread_aggregate_bool_exp_bool_or_arguments_columns" columns of table "thread"
"""
enum thread_select_column_thread_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived
}

"""
input type for updating data in table "thread"
"""
input thread_set_input {
  archived: Boolean
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  initiatorMemberId: uuid
  lastActivityDate: timestamptz
  lastActivityId: uuid
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  title: String
}

"""
Streaming cursor of the table "thread"
"""
input thread_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: thread_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input thread_stream_cursor_value_input {
  archived: Boolean
  circleId: uuid
  createdAt: timestamptz
  id: uuid
  initiatorMemberId: uuid
  lastActivityDate: timestamptz
  lastActivityId: uuid
  orgId: uuid
  participantsMembersIds: json
  participantsScope: member_scope_enum
  title: String
}

"""
update columns of table "thread"
"""
enum thread_update_column {
  """column name"""
  archived

  """column name"""
  circleId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  initiatorMemberId

  """column name"""
  lastActivityDate

  """column name"""
  lastActivityId

  """column name"""
  orgId

  """column name"""
  participantsMembersIds

  """column name"""
  participantsScope

  """column name"""
  title
}

input thread_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: thread_set_input
  where: thread_bool_exp!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
  activeMfaType: String
  avatarUrl: String!
  createdAt: timestamptz!
  currentChallenge: String
  defaultRole: String!

  """An object relationship"""
  defaultRoleByRole: authRoles!
  disabled: Boolean!
  displayName: String!
  email: citext
  emailVerified: Boolean!
  id: uuid!
  isAnonymous: Boolean!
  lastSeen: timestamptz
  locale: String!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz!
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  securityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """An aggregate relationship"""
  securityKeys_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!
  ticket: String
  ticketExpiresAt: timestamptz!
  totpSecret: String
  updatedAt: timestamptz!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "auth.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  currentChallenge: String_comparison_exp
  defaultRole: String_comparison_exp
  defaultRoleByRole: authRoles_bool_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  id: uuid_comparison_exp
  isAnonymous: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  members: member_bool_exp
  members_aggregate: member_aggregate_bool_exp
  metadata: jsonb_comparison_exp
  newEmail: citext_comparison_exp
  otpHash: String_comparison_exp
  otpHashExpiresAt: timestamptz_comparison_exp
  otpMethodLastUsed: String_comparison_exp
  passwordHash: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  roles: authUserRoles_bool_exp
  roles_aggregate: authUserRoles_aggregate_bool_exp
  securityKeys: authUserSecurityKeys_bool_exp
  securityKeys_aggregate: authUserSecurityKeys_aggregate_bool_exp
  ticket: String_comparison_exp
  ticketExpiresAt: timestamptz_comparison_exp
  totpSecret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  users_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.users"
"""
input users_insert_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  defaultRoleByRole: authRoles_obj_rel_insert_input
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  members: member_arr_rel_insert_input
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  roles: authUserRoles_arr_rel_insert_input
  securityKeys: authUserSecurityKeys_arr_rel_insert_input
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth.users"
"""
input users_max_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth.users"
"""
input users_min_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  defaultRoleByRole: authRoles_order_by
  disabled: order_by
  displayName: order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  isAnonymous: order_by
  lastSeen: order_by
  locale: order_by
  members_aggregate: member_aggregate_order_by
  metadata: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
update columns of table "auth.users"
"""
enum users_update_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

input users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}